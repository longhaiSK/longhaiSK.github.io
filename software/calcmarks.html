<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Mark Calculator (Shinylive)</title>

    <script src="https://shinylive.io/shinylive/shinylive.js"></script>
    <link rel="stylesheet" href="https://shinylive.io/shinylive/shinylive.css">

    <style>
        /* Optional: Add some basic styling or loading indicator */
        body { font-family: sans-serif; margin: 0; padding: 0; }
        /* A simple loading indicator */
        #loading-indicator {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 1.5em; color: #555; z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="loading-indicator">Loading Shinylive App...</div>

    <script type="text/shinylive-r" data-appmode="quarto-doc">
## file: app.R

# --- Load Libraries ---
# Shinylive will attempt to install/load these via webR's package mechanisms.
# This might take time on first load and depends on package compatibility.
library(shiny)
library(tidyverse) # Includes dplyr, stringr, readr, ggplot2, tidyr
library(DT)        # For interactive tables
library(rhandsontable) # For spreadsheet view
library(shinyjs)   # Optional, but potentially useful
library(shinyWidgets) # Optional, for potentially nicer inputs
library(ggplot2)   # For plotting (loaded via tidyverse)
library(scales)    # For plot scales (like percent)
library(shinythemes) # Optional: for theme
library(shinyBS)   # Required for popovers/tooltips
library(lubridate) # For date formatting (Sys.Date())
library(knitr)     # For formatting tables as text
library(patchwork) # For combining plots
library(sortable)  # For rank_list
library(writexl)   # For creating Excel files in download handler
library(tools)     # For file_path_sans_ext

# --- Helper Functions ---
# maxmean remains the same
maxmean <- function(x, n) {
  x_numeric <- suppressWarnings(as.numeric(x))
  x_numeric <- x_numeric[!is.na(x_numeric)]
  if (length(x_numeric) == 0) return(NA_real_)
  n <- max(1, min(length(x_numeric), floor(n))) # Ensure n is valid
  mean(sort(x_numeric, decreasing = TRUE)[1:n], na.rm = TRUE)
}

# identify_columns now takes df and performs PP row check
identify_columns <- function(df) {
  # Input validation
  if (!is.data.frame(df) || nrow(df) < 2) {
    stop("Input must be a data frame with at least 2 rows (including Points Possible).")
  }
  col_names <- colnames(df)

  # 1. Identify Student Column (Name only)
  student_col <- grep("^Student", col_names, value = TRUE, ignore.case = TRUE)[1]
  if (is.na(student_col) || !student_col %in% col_names) {
    stop("Cannot identify 'Student' column based on name pattern '^Student'.")
  }

  # 2. Find Points Possible Row Index
  student_vector <- df[[student_col]]
  points_possible_row_idx <- which(tolower(student_vector) == "points possible")
  if (length(points_possible_row_idx) != 1) {
    stop("Could not find exactly one 'Points Possible' row in the '", student_col, "' column.")
  }

  # 3. Initial Identification by Name Pattern
  hw_cols_potential <- str_subset(col_names, regex("^(HW|A)", ignore_case = TRUE))
  test_cols_potential <- str_subset(col_names, regex("^(Test|Midterm)", ignore_case = TRUE))
  final_col_potential <- str_subset(col_names, regex("^Final", ignore_case = TRUE))
  potential_mark_cols <- unique(c(hw_cols_potential, test_cols_potential, final_col_potential))

  # 4. Filter Mark Columns based on Numeric PP Row Value
  cols_to_keep <- c()
  if (length(potential_mark_cols) > 0) {
    # Ensure potential columns actually exist before trying to access them
    potential_mark_cols_exist <- intersect(potential_mark_cols, col_names)
    if (length(potential_mark_cols_exist) > 0) {
      pp_values <- df[points_possible_row_idx, potential_mark_cols_exist, drop = FALSE]
      for (col_name in potential_mark_cols_exist) {
        raw_value <- pp_values[[col_name]]
        # Check if not missing/empty and is convertible to number
        is_valid_numeric <- !is.null(raw_value) &&
          !is.na(raw_value) &&
          !(is.character(raw_value) && str_trim(raw_value) == "") &&
          !is.na(suppressWarnings(as.numeric(raw_value)))

        if (is_valid_numeric) {
          cols_to_keep <- c(cols_to_keep, col_name)
        }
      }
    }
  }

  # 5. Create Final Filtered Lists
  hw_cols_final <- intersect(hw_cols_potential, cols_to_keep)
  test_cols_final <- intersect(test_cols_potential, cols_to_keep)
  # Handle final column slightly differently - expect only one candidate after filtering
  final_col_candidates <- intersect(final_col_potential, cols_to_keep)
  final_col_final <- if (length(final_col_candidates) == 1) final_col_candidates else NA_character_

  # 6. Identify ID Column (Name only)
  id_col <- NA_character_ # Default to NA
  sis_user_id_match_idx <- which(tolower(col_names) == "sis user id")
  if (length(sis_user_id_match_idx) > 0) {
    id_col <- col_names[sis_user_id_match_idx[1]]
  } else {
    alt_id_matches <- grep("^ID$|^Student[._ ]?ID$", col_names, value = TRUE, ignore.case = TRUE)
    if (length(alt_id_matches) > 0) {
      id_col <- alt_id_matches[1]
    }
  }

  # 7. Return final list
  final_mark_cols = unique(c(hw_cols_final, test_cols_final, final_col_final))
  final_mark_cols = final_mark_cols[!is.na(final_mark_cols)] # Remove NA from final col if needed

  list(
    hw = hw_cols_final,
    test = test_cols_final,
    final = final_col_final, # Could be NA if not exactly one valid found
    student = student_col,
    id = id_col,              # Could be NA
    marks = final_mark_cols   # Contains only cols that passed name AND PP numeric check
  )
}

# parse_adjustment_rules remains the same
parse_adjustment_rules <- function(rules_string) {
  if (is.null(rules_string) || str_trim(rules_string) == "") { return(list()) }
  rules_parts <- str_split(rules_string, ";")[[1]]
  parsed_rules <- list(); rule_index <- 1
  for (part in rules_parts) {
    part <- str_trim(part); if (part == "") next
    match <- str_match(part, "^\\[\\s*(-?\\d+(?:\\.\\d+)?)\\s*,\\s*(-?\\d+(?:\\.\\d+)?)\\s*\\]\\s*:\\s*(-?\\d+(?:\\.\\d+)?)\\s*$")
    if (is.na(match[1, 1])) { stop(paste0("Invalid format in rule #", rule_index, ": '", part, "'.")) }
    lower_b <- suppressWarnings(as.numeric(match[1, 2])); upper_b <- suppressWarnings(as.numeric(match[1, 3])); mark_add <- suppressWarnings(as.numeric(match[1, 4]))
    if (is.na(lower_b) || is.na(upper_b) || is.na(mark_add)) { stop(paste0("Non-numeric value found in rule #", rule_index, ": '", part, "'")) }
    if (lower_b >= upper_b) { stop(paste0("Lower bound (", lower_b, ") must be < Upper bound (", upper_b, ") in rule #", rule_index)) }
    parsed_rules[[length(parsed_rules) + 1]] <- list(lower = lower_b, upper = upper_b, added = mark_add); rule_index <- rule_index + 1
  }
  return(parsed_rules)
}

# --- Helper Function: Generate Notes as Plain Text (Includes Credit Line) ---
generate_notes_text <- function(params, cols_info) {
  if (is.null(params) || is.null(cols_info)) {
    return("Calculation parameters or column information not available.")
  }

  student_col_name_actual <- if(!is.na(cols_info$student)) cols_info$student else "Student Col?"
  id_col_name_actual <- if(!is.na(cols_info$id)) cols_info$id else "ID Col?"

  weights_str <- sprintf("Weights (as decimals): HW=%.3f, Test=%.3f, Final=%.3f", params$weights["HW"], params$weights["Test"], params$weights["Final"])
  options_str <- sprintf("Options: Fill HW=%s, Fill Test=%s, MaxFinal=%s", params$fill.hw, params$fill.test, params$final.only)
  omissions_str <- sprintf("Omissions: Omit HW=%d, Omit Test=%d", params$n.omitted.hw, params$n.omitted.test)
  rules_display <- if (!is.null(params$adjustment_rules_string) && nzchar(str_trim(params$adjustment_rules_string))) {
    sprintf("Adjustment Rules String Used: %s", params$adjustment_rules_string)
  } else {
    "Adjustments: None applied."
  }

  col_defs <- paste(
    "Column Definitions (in results table):",
    paste0("  ", student_col_name_actual, "/", id_col_name_actual, ": Student identifiers."),
    paste0("  Nhw/Ntest: # Submitted HW/Test (using only columns with valid Points Possible)."),
    paste0("  HW/Test: Weighted component score %."),
    paste0("  Final_Score: Final Exam score %."),
    paste0("  calculated: Initial total % = Weighted(HW+Test+Final)."),
    paste0("  maxFinal: Max(calculated, Final_Score) if option checked."),
    paste0("  submitted: Final rounded grade % (capped at rule's upper bound or 99 overall)."),
    sep = "\n"
  )

  display_note <- paste(
    "Note on Exported Table:",
    paste0("  The following table shows only rows where the identified ID column (", id_col_name_actual, ") contains a numeric value and excludes the 'Points Possible' row."),
    paste0("  Calculated results for the 'Points Possible' row and rows with non-numeric IDs are shown separately in the 'Verification Information' section within the app."),
    sep = "\n"
  )

  # Credit Line
  app_credit_line <- "This file is made by https://longhai.shinyapps.io/marks/"

  # Combine all parts into a single string
  paste(
    "--- Calculation Notes ---",
    "Parameters Used:",
    paste0("  ", weights_str),
    paste0("  ", options_str),
    paste0("  ", omissions_str),
    paste0("  ", rules_display),
    "---",
    col_defs,
    "---",
    display_note,
    "---",
    app_credit_line, # Added the credit line here
    "---",
    "", # Add an empty line before the table data
    sep = "\n"
  )
}


# --- Core Calculation Function (Unchanged) ---
#' @throws Error if essential columns ('Final') are missing/invalid after identification.
calculate_grades <- function(df, params) {
  df_original <- df # Keep original for raw display prep later

  # --- Use identify_columns (performs name and PP numeric checks) ---
  cols <- identify_columns(df)

  # --- Basic Setup & Validation ---
  # Handle ID column (add placeholder if NA)
  if (is.na(cols$id)) {
    cols$id <- "Student.ID.Placeholder"; if (!cols$id %in% colnames(df)) df[[cols$id]] <- NA
    warning("Could not identify Student ID column ('SIS User ID', 'ID', 'Student ID'). Using placeholder.")
  } else if (!cols$id %in% colnames(df)) {
    stop(paste("Identified ID column '", cols$id, "' not found in data frame.", sep=""))
  }

  # Validate essential Final column
  if (is.na(cols$final) || length(cols$final) != 1) {
    final_col_potential_names <- str_subset(colnames(df_original), regex("^Final", ignore_case = TRUE))
    stop(paste("Could not identify exactly one 'Final' column that also has a numeric 'Points Possible' value. Potential names found based on pattern:", paste(final_col_potential_names, collapse=", ")))
  }

  # Validate that *some* mark columns remain
  if (length(cols$marks) == 0) {
    stop("No mark columns (HW*, Test*, Final*) remain after checking name patterns and 'Points Possible' row values.")
  }

  # --- Get PP row index ---
  points_possible_row_idx <- which(tolower(df[[cols$student]]) == "points possible")
  valid_mark_cols <- cols$marks

  # --- Data Cleaning & Percentage Calculation ---
  marks_processed <- df %>%
    mutate(across(all_of(valid_mark_cols), as.character)) %>%
    mutate(across(all_of(valid_mark_cols), ~ suppressWarnings(as.numeric(.)))) %>%
    mutate(across(all_of(valid_mark_cols), ~ replace_na(., 0)))

  # Extract Points Possible values *only for the valid columns*
  points_possible <- as.numeric(marks_processed[points_possible_row_idx, valid_mark_cols])
  if (any(is.na(points_possible))) {
    stop("Internal Error: NA values found in 'Points Possible' row for columns previously identified as valid.")
  }
  if (any(points_possible <= 0)) {
    invalid_pp_cols <- valid_mark_cols[points_possible <= 0]
    warning(paste("Non-positive values found in 'Points Possible' row for identified columns:", paste(invalid_pp_cols, collapse=", "), ". Calculations might be affected. Consider correcting the CSV."))
  }
  points_possible_map <- setNames(points_possible, valid_mark_cols)

  # --- Keep ALL rows (including PP) for calculation ---
  students_df <- marks_processed %>%
    select(all_of(c(cols$student, cols$id, valid_mark_cols)))

  # Handle case where df might be empty except PP row
  if (nrow(students_df) == 0) {
    warning("Data frame became empty unexpectedly during processing.")
    final_output_cols <- c(cols$student, cols$id, "Nhw", "HW", "Ntest", "Test", "Final_Score", "calculated", "maxFinal", "adjusted", "submitted")
    empty_results <- data.frame(matrix(ncol = length(final_output_cols), nrow = 0))
    colnames(empty_results) <- final_output_cols
    raw_marks_display_internal_empty <- df_original[0, ]
    return(list(processed_marks = empty_results, raw_marks_display = raw_marks_display_internal_empty, identified_columns = cols))
  }

  # Calculate percentage scores
  for (col in valid_mark_cols) {
    if (col %in% names(students_df) && !is.null(points_possible_map[[col]]) && points_possible_map[[col]] != 0) {
      students_df[[col]] <- (students_df[[col]] / points_possible_map[[col]]) * 100
    } else { students_df[[col]] <- 0 }
  }

  # --- Apply Fill Options ---
  if (cols$final %in% names(students_df)) {
    final_scores_perc <- students_df[[cols$final]]
    if (params$fill.test && length(cols$test) > 0) {
      valid_fill_test_cols <- intersect(cols$test, names(students_df))
      if(length(valid_fill_test_cols) > 0) students_df <- students_df %>% mutate(across(all_of(valid_fill_test_cols), ~ pmax(., final_scores_perc, na.rm = TRUE)))
    }
    if (params$fill.hw && length(cols$hw) > 0) {
      valid_fill_hw_cols <- intersect(cols$hw, names(students_df))
      if(length(valid_fill_hw_cols) > 0) students_df <- students_df %>% mutate(across(all_of(valid_fill_hw_cols), ~ pmax(., final_scores_perc, na.rm = TRUE)))
    }
  } else {
    stop("Internal Error: Final column identified but not found in students_df for fill operation.")
  }

  # --- Calculate Weighted Component Scores ---
  valid_hw_cols <- cols$hw # Already filtered
  valid_test_cols <- cols$test # Already filtered
  n_hw_total <- length(valid_hw_cols)
  n_test_total <- length(valid_test_cols)
  n_hw_effective <- max(0, min(n_hw_total, n_hw_total - params$n.omitted.hw))
  n_test_effective <- max(0, min(n_test_total, n_test_total - params$n.omitted.test))

  students_df <- students_df %>% mutate(
    Nhw = if (n_hw_total > 0) rowSums(select(., all_of(valid_hw_cols)) != 0, na.rm = TRUE) else 0,
    Ntest = if (n_test_total > 0) rowSums(select(., all_of(valid_test_cols)) != 0, na.rm = TRUE) else 0
  )

  students_df$HW_Avg <- if (n_hw_effective > 0 && n_hw_total > 0) { apply(students_df[, valid_hw_cols, drop = FALSE], 1, maxmean, n = n_hw_effective) } else { 0 }
  students_df$Test_Avg <- if (n_test_effective > 0 && n_test_total > 0) { apply(students_df[, valid_test_cols, drop = FALSE], 1, maxmean, n = n_test_effective) } else { 0 }

  students_df <- students_df %>% mutate(
    HW = coalesce(HW_Avg * params$weights["HW"], 0),
    Test = coalesce(Test_Avg * params$weights["Test"], 0),
    Final_Score = if (cols$final %in% names(.)) .[[cols$final]] else NA_real_,
    Final_Weighted = coalesce(Final_Score * params$weights["Final"], 0)
  )

  # --- Calculate Overall Scores ---
  students_df <- students_df %>% mutate(
    Term = HW + Test,
    calculated = Term + Final_Weighted
  )

  # Initialize maxFinal based on 'calculated'
  students_df$maxFinal <- students_df$calculated

  # Apply the max logic
  if(params$final.only == TRUE && "Final_Score" %in% names(students_df)) {
    if(is.numeric(students_df$calculated) && is.numeric(students_df$Final_Score)) {
      if(length(students_df$calculated) == length(students_df$Final_Score)) {
        idx_valid_final <- !is.na(students_df$Final_Score)
        if(any(idx_valid_final)) {
          students_df$maxFinal[idx_valid_final] <- pmax(
            students_df$calculated[idx_valid_final],
            students_df$Final_Score[idx_valid_final],
            na.rm = TRUE
          )
        }
      } else {
        warning("Length mismatch between 'calculated' and 'Final_Score'. Using 'calculated' for 'maxFinal'.")
      }
    } else {
      warning("'Final_Score' or 'calculated' column is not numeric. Using 'calculated' for 'maxFinal'.")
    }
  }

  # === Apply Adjustments ===
  students_df$adjusted <- students_df$maxFinal; max_score_cap <- 99; adjustment_rules <- params$adjustment_rules
  if (length(adjustment_rules) > 0 && "maxFinal" %in% names(students_df)) {
    sorted_rules <- adjustment_rules[order(sapply(adjustment_rules, `[[`, "lower"), decreasing = TRUE)]; adjusted_indices <- c()
    for (rule in sorted_rules) {
      lower_b <- rule$lower; upper_b <- rule$upper; mark_add <- rule$added
      if (!"adjusted" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal

      students_sel_idx <- which( !is.na(students_df$maxFinal) & students_df$maxFinal >= lower_b & students_df$maxFinal < upper_b & !(seq_len(nrow(students_df)) %in% adjusted_indices) )
      if (length(students_sel_idx) > 0) {
        adjusted_values <- students_df$maxFinal[students_sel_idx] + mark_add
        students_df$adjusted[students_sel_idx] <- pmin(adjusted_values, upper_b ); adjusted_indices <- c(adjusted_indices, students_sel_idx)
      }
    }
    students_df <- students_df %>% mutate(adjusted = pmin(adjusted, max_score_cap))
  } else {
    if (!"adjusted" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal
    students_df <- students_df %>% mutate(adjusted = pmin(adjusted, max_score_cap))
  }

  # --- Final Rounding ---
  if (!"adjusted" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal
  students_df <- students_df %>% mutate( submitted = round(adjusted) )

  # --- Final Output Selection ---
  final_output_cols <- c( cols$student, cols$id, "Nhw", "HW", "Ntest", "Test", "Final_Score", "calculated", "maxFinal", "adjusted", "submitted" )
  final_output_cols_exist <- intersect(final_output_cols, names(students_df))
  processed_marks_final <- students_df %>%
    select(all_of(final_output_cols_exist)) %>%
    arrange(if("submitted" %in% final_output_cols_exist && is.numeric(.$submitted)) desc(submitted) else 1)


  # --- Internal Raw Marks Display Preparation ---
  cols_orig_for_raw <- identify_columns(df_original)
  raw_display_cols <- unique(c(cols_orig_for_raw$student, cols_orig_for_raw$id, cols_orig_for_raw$marks))
  raw_display_cols <- raw_display_cols[!is.na(raw_display_cols)]
  student_col_raw <- cols_orig_for_raw$student
  if(is.na(student_col_raw) || !student_col_raw %in% colnames(df_original)){
    warning("Cannot identify student column in original data for raw preview preparation.")
    raw_marks_display_internal <- data.frame(Message = "Error: Could not find student column for raw preview.")
  } else {
    points_possible_row_idx_for_raw <- which(tolower(df_original[[student_col_raw]]) == "points possible")
    raw_display_cols <- intersect(raw_display_cols, colnames(df_original))
    if(length(points_possible_row_idx_for_raw) == 1 && length(raw_display_cols) > 0) {
      raw_marks_display_internal <- df_original %>% select(all_of(raw_display_cols))
      points_possible_row_data_internal <- raw_marks_display_internal[points_possible_row_idx_for_raw, , drop = FALSE]
      student_rows_internal <- raw_marks_display_internal[-points_possible_row_idx_for_raw, , drop = FALSE]
      raw_marks_display_internal <- bind_rows(points_possible_row_data_internal, student_rows_internal)
      colnames(raw_marks_display_internal) <- str_replace(colnames(raw_marks_display_internal), "\\.\\.\\d+\\.?", "")
    } else {
      warning("Could not prepare the raw marks display section using original data.")
      raw_marks_display_internal <- data.frame(Message = "Could not generate raw preview for calculation results.")
      if(!is.null(df_original)) raw_marks_display_internal <- df_original
    }
  }

  # --- Return ---
  return(list(processed_marks = processed_marks_final,
              raw_marks_display = raw_marks_display_internal,
              identified_columns = cols))
}


# --- Define UI (Includes Wider fileInput & Custom Downloads) ---
ui <- fluidPage(
  tags$head(tags$style(HTML("body { font-family: sans-serif; }
                              .btn-xs { padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; }
                              .btn-sm { padding: .25rem .5rem; font-size: .875rem; line-height: 1.5; border-radius: .2rem; }"))),
  theme = shinytheme("spacelab"),
  titlePanel("Student Mark Calculator"),

  sidebarLayout(
    # Sidebar Panel: Calculation Controls (Unchanged)
    sidebarPanel(
      width = 3,
      h4("Calculation Controls"), tags$hr(),
      h5("Component Weights (%)"),
      fluidRow(
        column(4, numericInput("weight_hw", "HW %", value = 30, min = 0, max = 100, step = 1)),
        column(4, numericInput("weight_test", "Test %", value = 20, min = 0, max = 100, step = 1)),
        column(4, numericInput("weight_final", "Final %", value = 50, min = 0, max = 100, step = 1))
      ),
      textOutput("weight_sum_check"), tags$hr(),
      h5("Fill / Max Options"),
      checkboxInput("fill_hw", "Fill missing/lower HW w/ Final %", value = FALSE),
      checkboxInput("fill_test", "Fill missing/lower Test w/ Final %", value = TRUE),
      checkboxInput("final_only", "Grade = max(Calculated, Final %)", value = FALSE), tags$hr(),
      h5("Omit Lowest Scores"),
      fluidRow(
        column(6, numericInput("n_omitted_hw", "# Omitted HWs", value = 0, min = 0, step = 1)),
        column(6, numericInput("n_omitted_test", "# Omitted Tests", value = 0, min = 0, step = 1))
      ), tags$hr(),
      div(style="display: flex; align-items: center; justify-content: space-between;",
          h5("Grade Adjustment Rules", style="margin-bottom: 0;"),
          tags$a(id = "adj_rules_help", href = "#", onclick="return false;", icon("question-circle", class = "fa-lg"), style = "margin-left: 5px; color: #007bff; cursor: pointer; text-decoration: none;")
      ),
      bsPopover(id = "adj_rules_help", title = "Adjustment Rule Format",
                content = HTML(paste("Enter rules using the format: <code>[Lower, Upper]: Added</code>",
                                     "Rules must be separated by semicolons (<code>;</code>).",
                                     "<em>Example:</em><br/><code>[0, 50]: 2; [50, 70]: 4; [70, 100]: 0</code>",
                                     "A student's score falling within <code>[Lower, Upper)</code> gets points added.",
                                     "Adjusted score capped at rule's <code>Upper</code> bound OR 99 overall (whichever is lower).",
                                     sep = "<br/><br/>")),
                placement = "right", trigger = "click", options = list(container = "body")
      ),
      textInput("adjustment_rules_text", label = NULL, placeholder = "[L1, U1]: A1; [L2, U2]: A2; ...", value = "[0,50]: 0; [50, 70]: 0; [70, 100]: 0"), # User default value
      tags$hr(),
      # --- Author Information Added Here ---
      tags$div(style = "margin-top: 20px; font-size: 0.9em; color: grey; text-align: center;",
               HTML('Author: Longhai Li<br>(<a href="https://longhaisk.github.io" target="_blank">https://longhaisk.github.io</a>)')
      )
    ), # End sidebarPanel

    # Main Panel: Tabs
    mainPanel(
      width = 9,
      tabsetPanel(
        id = "mainTabs",
        # Tab 1: Uploading Marks (Wider fileInput)
        tabPanel("Uploading Marks",
                 h4("Upload Mark File"),
                 # MODIFIED: Added width = '100%'
                 fileInput("markFile", "Choose CSV File",
                           accept = c(".csv", "text/csv"),
                           width = '100%'
                 ),
                 verbatimTextOutput("fileReadStatusOutput", placeholder = TRUE),
                 h4("Input Data Preview (Identified & Validated Columns)"),
                 DTOutput("rawMarksTable"),
                 hr(),
                 h4("Columns Identified by Category"),
                 verbatimTextOutput("identifiedColumnsText")
        ), # End Uploading Marks tabPanel

        # Tab 2: Calculating Grades (Conditional display & Custom Downloads)
        tabPanel("Calculating Grades",
                 h4("Calculate & View Processed Marks"),
                 actionButton("calculate", "Calculate Grades", icon = icon("calculator"), class = "btn-primary", style="margin-bottom: 5px;"),
                 tags$p(em("Configure Controling Parameters in the Sidebar and Click Calculate."), style="margin-top: 10px; margin-bottom: 15px; color: #555; font-size:0.9em;"),
                 hr(), # Separator before display options

                 # Display options and Reorder button
                 fluidRow(
                   column(width = 4, radioButtons("results_view_type", "Select Display:", choices = c("Interactive Table" = "Table", "Spreadsheet View" = "Spreadsheet"), selected = "Table", inline = TRUE)),
                   column(width = 2, div(style="margin-top: 5px;", actionButton(inputId = "showReorderUI", label = "Reorder Columns", icon = icon("sort"))))
                 ),
                 tags$hr(style="margin-top:0px;"),

                 # Render Table/Spreadsheet UI directly via conditionalPanel
                 conditionalPanel(
                   condition = "input.results_view_type == 'Table'",
                   DTOutput("processedMarksTable")
                 ),
                 conditionalPanel(
                   condition = "input.results_view_type == 'Spreadsheet'",
                   rHandsontableOutput("processedMarksSpreadsheet")
                 ),

                 # Custom Download Buttons
                 hr(),
                 h4("Export Processed Marks with Notes"),
                 fluidRow(
                   column(width = 3,
                          downloadButton("downloadCsvWithNotes", "Download CSV w/ Notes", class="btn-sm")
                   ),
                   column(width = 3,
                          downloadButton("downloadXlsxWithNotes", "Download Excel w/ Notes", class="btn-sm")
                   )
                 ),

                 # Verification Info
                 hr(),
                 h4("Additional Rows for Verification"),
                 tags$p(em("Shows calculated results for the 'Points Possible' row and any rows excluded from the main table above due to non-numeric IDs."), style="color: #555; font-size:0.9em;"),
                 uiOutput("specialRowsInfoUI"),

                 # In-App Calculation Notes
                 hr(),
                 h4("Calculation Notes"),
                 uiOutput("processedMarksNotes"),
                 hr()
        ), # End Calculating Grades tabPanel

        # Tab 3: Statistics & Plots (Unchanged)
        tabPanel("Statistics & Plots",
                 h4("Summary Statistics for Submitted Marks "),
                 verbatimTextOutput("summaryStats"),
                 hr(),
                 h4("Distribution Plots "),
                 plotOutput("distPlots", height = "450px")
        ), # End Stats tabPanel

        # Tab 4: Help (Updated instructions)
        tabPanel("Help",
                 h3("How to Use This Calculator"),
                 tags$ol(
                   tags$li(tags$strong("Upload CSV:"), " Go to the 'Uploading Marks' tab and select your gradebook export. It needs a 'Student' column and a 'Points Possible' row containing positive numeric values for columns to be included."),
                   tags$li(tags$strong("Preview Raw Data:"), " On the 'Uploading Marks' tab, a preview appears showing only identified student, ID, and mark columns that have numeric 'Points Possible' values. Below the preview, a summary lists the columns identified for each category (HW, Test, Final)."),
                   tags$li(tags$strong("Set Parameters:"), " Use the 'Calculation Controls' sidebar for Weights (as %), Fill/Omit options, and Adjustment Rules. Click the ", icon("question-circle"), " icon for help on adjustment rules."),
                   tags$li(tags$strong("Set Adjustments:"), " Use the 'Grade Adjustment Rules' text box in the sidebar."),
                   tags$li(tags$strong("Calculate:"), " Go to 'Calculating Grades' tab, click the 'Calculate Grades' button."),
                   tags$li(tags$strong("Define Column Order (Optional):"), " On the 'Calculating Grades' tab, click the 'Reorder Display Columns' button located beside the 'Select Display' options. A pop-up window will appear where you can drag and drop column names to set your preferred display order for the results table/spreadsheet."),
                   tags$li(tags$strong("Review Results:"), " Check the main results table (respecting your chosen column order), the 'Calculation Notes' (in-app version), the 'Verification Information' section (for calculated 'Points Possible' row and non-numeric ID rows), and the 'Statistics & Plots' tab (based on numeric ID students)."),
                   tags$li(tags$strong("Export Results w/ Notes:"), " On the 'Calculating Grades' tab, use the 'Download CSV w/ Notes' or 'Download Excel w/ Notes' buttons below the results table to export the data along with the calculation parameters used. The filename will be based on your uploaded file.")
                 ),
                 h4("Column Naming Conventions"),
                 p("Tool identifies columns by name prefixes AND requires a numeric 'Points Possible' value:"),
                 tags$ul(tags$li("HW/Assign: 'HW'/'A'"), tags$li("Tests: 'Test'/'Midterm'"), tags$li("Final: 'Final'"),
                         tags$li("Student Name: 'Student'"), tags$li("ID: Prefers 'SIS User ID', finds 'ID'/'Student ID'")),
                 h4("Important Notes"),
                 tags$ul(
                   tags$li("Columns identified as marks (HW*, Test*, Final) MUST have a positive numeric value in the 'Points Possible' row to be included in calculations."),
                   tags$li("Missing student scores are treated as 0 (unless 'Fill' active)."),
                   tags$li("'Spreadsheet View' is read-only."),
                   tags$li("Ensure weights sum to 100%."),
                   tags$li("The main results table/spreadsheet and the statistics/plots only include students whose identified ID is numeric. Calculated results for the 'Points Possible' row and rows with non-numeric IDs (e.g., 'Test Student') are shown separately in the 'Verification Information' section on the 'Calculating Grades' tab."),
                   tags$li("Exported files (CSV/Excel) via the download buttons contain the calculation notes/parameters used and are named based on the input file.")
                 )
        ) # End Help tabPanel
      ) # End tabsetPanel
    ) # End mainPanel
  ) # End sidebarLayout
) # End fluidPage


# --- Define Server Logic (Includes Custom Downloads with Notes & Filenames) ---
server <- function(input, output, session) {

  rv <- reactiveValues(
    raw_data = NULL,
    raw_data_preview = NULL,
    identified_cols_list = NULL,
    calculated_results = NULL,
    calculation_params = NULL,
    file_status_msg = "Upload a CSV file on the 'Uploading Marks' tab.",
    calculation_error = NULL,
    current_column_order = NULL
  )

  # --- File Input Handling (Revised Filtering Logic) ---
  observeEvent(input$markFile, {
    req(input$markFile); infile <- input$markFile

    # Reset reactive values on new file upload
    rv$file_status_msg <- "Reading file..."; rv$raw_data <- NULL; rv$raw_data_preview <- NULL; rv$calculated_results <- NULL
    rv$calculation_params <- NULL; rv$calculation_error <- NULL; rv$identified_cols_list <- NULL
    rv$current_column_order <- NULL

    tryCatch({
      # Step 1: Read the raw CSV data
      # NOTE: In webR/Shinylive, fileInput gives a list where $name is filename
      # and $content is raw binary data. We need to handle this.
      # We'll use readr::read_csv on the raw content.
      # Assuming infile$content is the raw vector if this runs in Shinylive context.
      # If running locally, infile$datapath would be used.
      # Let's try to handle both cases, prioritizing content for webR:
      file_content <- NULL
      if (!is.null(infile$content)) {
          file_content <- rawToChar(infile$content)
      } else if (!is.null(infile$datapath)) {
          # Fallback for local execution? Might not be needed for pure Shinylive
          # file_content <- readChar(infile$datapath, file.info(infile$datapath)$size)
          # Safer to just read directly
          df_read <- read_csv(infile$datapath, show_col_types = FALSE, na = c("", "NA", "#N/A"), guess_max = 10000, trim_ws = TRUE)

      } else {
          stop("Could not access file content or path.")
      }

      # If content was read, parse it
      if (!is.null(file_content)) {
           df_read <- read_csv(file_content, show_col_types = FALSE, na = c("", "NA", "#N/A"), guess_max = 10000, trim_ws = TRUE)
      }


      if (nrow(df_read) < 2) stop("CSV file must contain at least 2 rows (including 'Points Possible').")
      raw_data_temp <- as.data.frame(df_read)
      original_row_count <- nrow(raw_data_temp)
      rv$file_status_msg <- "File read. Identifying columns..."

      # Step 2: Initial column identification on the *original* data
      identified_cols_initial <- identify_columns(raw_data_temp)
      student_col_name <- identified_cols_initial$student
      if (is.na(student_col_name) || !student_col_name %in% colnames(raw_data_temp)) {
        stop("Cannot identify the 'Student' column in the uploaded file.")
      }
      mark_cols_to_check <- identified_cols_initial$marks # Use all identified mark columns for filtering check
      rv$file_status_msg <- "Columns identified. Filtering rows..."

      # Step 3: Filter rows based on numeric content in identified mark columns
      filtered_data <- raw_data_temp
      rows_removed <- 0

      # Find the 'Points Possible' row index *before* filtering
      points_possible_row_idx <- which(tolower(raw_data_temp[[student_col_name]]) == "points possible")
      if (length(points_possible_row_idx) != 1) {
        stop("Could not find exactly one 'Points Possible' row in the '", student_col_name, "' column.")
      }

      if (length(mark_cols_to_check) > 0) {
        # Ensure the mark columns actually exist in the dataframe
        valid_filter_cols <- intersect(mark_cols_to_check, colnames(raw_data_temp))

        if (length(valid_filter_cols) > 0) {
          # Keep the 'Points Possible' row AND rows where AT LEAST ONE mark column is numeric
          filtered_data <- raw_data_temp %>%
            dplyr::filter(
              # Condition 1: Keep the Points Possible row explicitly
              dplyr::row_number() == points_possible_row_idx |
                # Condition 2: Keep rows where *any* of the identified mark columns are numeric
                dplyr::if_any(
                  dplyr::all_of(valid_filter_cols),
                  ~ !is.na(suppressWarnings(as.numeric(.))) # Check if value can be numeric
                )
            )
          filtered_row_count <- nrow(filtered_data)
          rows_removed <- original_row_count - filtered_row_count
          rv$file_status_msg <- paste("File read. Identified columns. Filtered", rows_removed, "rows lacking numeric data in all mark columns.")
        } else {
          warning("Filtering skipped: Identified mark columns not found in the data frame headers after initial read.")
          rv$file_status_msg <- "File read. Identified columns. Filtering skipped: No valid mark columns found."
        }
      } else {
        warning("Filtering skipped: No mark columns (HW, Test, Final) were identified by name and valid PP row value.")
        rv$file_status_msg <- "File read. Identified columns. Filtering skipped: No mark columns identified."
      }

      # Step 4: Check if enough rows remain after filtering
      if (nrow(filtered_data) < 2) {
        stop(paste("After filtering, less than 2 rows remain (only", nrow(filtered_data), "rows). Check if 'Points Possible' or essential student rows were unexpectedly removed. Original rows:", original_row_count))
      }

      # Step 5: Store the FILTERED data
      rv$raw_data <- filtered_data
      rv$file_status_msg <- paste(rv$file_status_msg, "Identifying final columns for calculation...")

      # Step 6: Re-identify columns based on the FILTERED data
      rv$identified_cols_list <- identify_columns(rv$raw_data)
      rv$file_status_msg <- paste(rv$file_status_msg, "Generating preview...")


      # Step 7: Generate preview using the FILTERED data and FINAL identified columns
      tryCatch({
        cols_preview <- rv$identified_cols_list # Use the final list based on filtered data
        # Re-validate student column presence after filtering and re-identification
        if (is.na(cols_preview$student) || !(cols_preview$student %in% colnames(rv$raw_data))) {
          stop("Cannot generate preview: Student column ('", cols_preview$student ,"') not found after filtering.")
        }

        # Define columns for the preview table (Student, ID, and FINAL identified Mark columns)
        valid_raw_display_cols <- unique(c(cols_preview$student, cols_preview$id, cols_preview$marks))
        valid_raw_display_cols <- valid_raw_display_cols[!is.na(valid_raw_display_cols)] # Remove NA if ID wasn't found
        valid_raw_display_cols <- intersect(valid_raw_display_cols, colnames(rv$raw_data)) # Ensure they exist in filtered data

        if (length(valid_raw_display_cols) > 0) {
          # Find 'Points Possible' row index *in the filtered data*
          points_possible_row_idx_preview <- which(tolower(rv$raw_data[[cols_preview$student]]) == "points possible")
          if(length(points_possible_row_idx_preview) != 1) {
            stop("Could not locate exactly one 'Points Possible' row in the filtered data for preview structuring.")
          }

          # Select columns and reorder rows for preview
          preview_df <- rv$raw_data %>% select(all_of(valid_raw_display_cols))
          points_possible_row_data_preview <- preview_df[points_possible_row_idx_preview, , drop = FALSE]
          student_rows_preview <- preview_df[-points_possible_row_idx_preview, , drop = FALSE]
          temp_preview <- bind_rows(points_possible_row_data_preview, student_rows_preview)

          # Clean up potential duplicate column names (e.g., from read_csv)
          colnames(temp_preview) <- str_replace(colnames(temp_preview), "\\.\\.\\.\\d+$", "") # More specific regex for ...# suffix
          colnames(temp_preview) <- make.unique(colnames(temp_preview)) # Ensure uniqueness if needed after cleaning

          rv$raw_data_preview <- temp_preview
          rv$file_status_msg <- paste0("File read successfully. Filtered ", rows_removed, " rows. Preview below shows identified columns from remaining data.")
        } else {
          stop("No valid columns (Student, ID, Marks) remain for preview after filtering and final identification.")
        }
      }, error = function(e_preview) {
        rv$raw_data_preview <- data.frame(Message=paste("Preview Error:", e_preview$message))
        rv$file_status_msg <- paste(rv$file_status_msg, "Preview generation failed:", e_preview$message)
        warning(paste("Could not generate structured raw preview:", e_preview$message))
      })

    }, error = function(e_main) {
      # Catch errors from reading, initial identification, filtering, or final identification
      error_message <- paste("Error during file processing:", e_main$message)
      rv$file_status_msg <- error_message
      showNotification(error_message, type = "error", duration = 10)
      # Reset all relevant reactive values on error
      rv$raw_data <- NULL; rv$raw_data_preview <- NULL; rv$identified_cols_list <- NULL
      rv$calculated_results <- NULL; rv$calculation_params <- NULL; rv$calculation_error <- NULL
      rv$current_column_order <- NULL
    })
  }) # End observeEvent input$markFile


  # --- Output: File Read Status (Unchanged) ---
  output$fileReadStatusOutput <- renderText({ rv$file_status_msg })

  # --- Output: Identified Columns Text (Unchanged) ---
  output$identifiedColumnsText <- renderPrint({
    req(rv$identified_cols_list)
    cols <- rv$identified_cols_list
    cat("--- Columns Identified (Post-Filtering) for Calculation ---\n")
    cat("Student Column:", ifelse(is.na(cols$student), "Not Found", cols$student), "\n")
    cat("ID Column:", ifelse(is.na(cols$id), "Not Found", cols$id), "\n")
    cat("Final Exam Column:", ifelse(is.na(cols$final) || !nzchar(cols$final), "Not Found / Invalid PP", cols$final), "\n")
    cat("Homework Columns (", length(cols$hw), "): ", if(length(cols$hw)>0) paste(cols$hw, collapse=", ") else "None", "\n", sep="")
    cat("Test Columns (", length(cols$test), "): ", if(length(cols$test)>0) paste(cols$test, collapse=", ") else "None", "\n", sep="")
    cat("----------------------------------------------------------\n")
  })

  # --- Parameter Validation: Weight Sum Check (Unchanged) ---
  output$weight_sum_check <- renderText({
    weights_perc <- c(input$weight_hw, input$weight_test, input$weight_final)
    if(any(is.na(weights_perc))) return("Enter numeric weights.")
    ws_perc <- sum(weights_perc)
    if (abs(ws_perc - 100.0) > 1e-6) {
      paste("Warning: Weights sum to", round(ws_perc, 2), "% (should be 100%)")
    } else {
      "Weights sum to 100%"
    }
  })

  # --- Adjustment Rules Popover (Unchanged - Requires shinyBS) ---
  observe({
    # Check if bsPopover function exists, might not if shinyBS fails to load in webR
    if(exists("bsPopover") && is.function(bsPopover)) {
      bsPopover(session=session, id = "adj_rules_help", title = "Adjustment Rule Format",
                content = HTML(paste("Enter rules using the format: <code>[Lower, Upper]: Added</code>",
                                     "Rules must be separated by semicolons (<code>;</code>).",
                                     "<em>Example:</em><br/><code>[0, 50]: 2; [50, 70]: 4; [70, 100]: 0</code>",
                                     "A student's score falling within <code>[Lower, Upper)</code> gets points added.",
                                     "Adjusted score capped at rule's <code>Upper</code> bound OR 99 overall (whichever is lower).",
                                     sep = "<br/><br/>")),
                placement = "right", trigger = "click", options = list(container = "body")
      )
    } else {
      # Optionally provide a fallback or warning if bsPopover isn't available
      # print("Warning: shinyBS::bsPopover not available.")
    }
  })


  # --- Calculation Trigger (Unchanged) ---
  observeEvent(input$calculate, {
    req(rv$raw_data, rv$identified_cols_list, cancelOutput = TRUE)

    if (is.null(rv$raw_data)) {
      showNotification("Cannot calculate: Filtered data is missing. Please re-upload.", type = "warning"); return()
    }
    if (is.null(rv$identified_cols_list)) {
      showNotification("Cannot calculate: Column identification failed after filtering. Please check file and re-upload.", type = "warning", duration=10); return()
    }

    # --- Parameter validation (weights, rules, omissions) ---
    weights_perc <- c(input$weight_hw, input$weight_test, input$weight_final)
    if(any(is.na(weights_perc))) { showNotification("Calculation aborted: One or more weights are not numeric.", type="error"); return() }
    if (abs(sum(weights_perc) - 100.0) > 1e-6) {
      showNotification(paste("Calculation aborted: Weights must sum to 100% (currently", round(sum(weights_perc),2), "%)"), type="error"); return()
    }
    weights_decimal <- c(HW = input$weight_hw / 100, Test = input$weight_test / 100, Final = input$weight_final / 100)

    adjustment_rules_list <- list(); rules_input_string <- input$adjustment_rules_text; validation_passed <- TRUE
    tryCatch({
      adjustment_rules_list <- parse_adjustment_rules(rules_input_string)
    }, error = function(e) {
      showNotification(paste("Error parsing adjustment rules:", e$message), type = "error", duration = 10); validation_passed <<- FALSE
    })
    if (!validation_passed) return()

    n_omit_hw <- floor(input$n_omitted_hw); n_omit_test <- floor(input$n_omitted_test)
    if(is.na(n_omit_hw) || n_omit_hw < 0 || is.na(n_omit_test) || n_omit_test < 0) {
      showNotification("Calculation aborted: Number of omitted scores must be a non-negative integer.", type="error"); return()
    }

    # --- Prepare parameters and run calculation ---
    current_params <- list(
      weights = weights_decimal,
      fill.hw = input$fill_hw, fill.test = input$fill_test, final.only = input$final_only,
      n.omitted.hw = n_omit_hw, n.omitted.test = n_omit_test,
      adjustment_rules_string = rules_input_string, adjustment_rules = adjustment_rules_list
    )
    rv$calculation_params <- current_params
    rv$calculation_error <- NULL # Clear previous errors

    tryCatch({
      showNotification("Calculating grades...", type = "message", duration = 2, id="calc_msg")
      results <- calculate_grades(rv$raw_data, current_params)
      rv$calculated_results <- results

      if (!is.null(results$processed_marks) && ncol(results$processed_marks) > 0) {
        initial_cols <- setdiff(colnames(results$processed_marks), "adjusted")
        rv$current_column_order <- initial_cols
      } else {
        rv$current_column_order <- NULL
      }

      rv$calculation_error <- NULL
      removeNotification("calc_msg", session=session)
      updateTabsetPanel(session, inputId = "mainTabs", selected = "Calculating Grades")
      showNotification("Calculations complete!", type = "message", duration = 5)

    }, error = function(e) {
      err_msg <- paste("Error during calculation:", e$message)
      rv$calculation_error <- err_msg
      rv$calculated_results <- NULL
      rv$current_column_order <- NULL
      removeNotification("calc_msg", session=session)
      showNotification(err_msg, type = "error", duration = 10)
      cat("\n--- Error Caught in Calculation ---\n"); print(e); cat("--- End Error Details ---\n\n")
    })
  }) # End observeEvent input$calculate


  # --- Show Modal Dialog for Column Reordering (Unchanged) ---
  observeEvent(input$showReorderUI, {
    req(rv$calculated_results$processed_marks)
    current_order <- rv$current_column_order
    if (is.null(current_order)) {
      initial_cols <- setdiff(colnames(rv$calculated_results$processed_marks), "adjusted")
      if(length(initial_cols) == 0){
        showNotification("Cannot determine columns to reorder.", type="warning")
        return()
      }
      current_order <- initial_cols
      rv$current_column_order <- current_order
    }

    # Check if sortable::rank_list exists
    if(exists("rank_list") && is.function(rank_list)) {
        showModal(modalDialog(
          title = "Reorder Table Columns",
          p("Drag and drop column names into the desired order."),
          rank_list(
            text = NULL,
            labels = current_order,
            input_id = "columnOrderModal",
            options = sortable_options()
          ),
          footer = tagList(
            modalButton("Cancel"),
            actionButton("applyColOrder", "Apply Order", class = "btn-primary")
          ),
          size = "m",
          easyClose = TRUE
        ))
    } else {
        showNotification("Error: 'sortable' package features not available.", type="error")
    }
  })

  # --- Observer to apply the order from the modal (Unchanged) ---
  observeEvent(input$applyColOrder, {
    req(input$columnOrderModal)
    rv$current_column_order <- input$columnOrderModal
    removeModal()
    showNotification("Column order updated.", type = "message", duration = 3)
  })


  # --- Reactive Expression for Processed Data to Display (Unchanged) ---
  display_data <- reactive({
    req(rv$calculated_results$processed_marks, rv$calculated_results$identified_columns)
    req(rv$current_column_order)

    processed_df <- rv$calculated_results$processed_marks
    cols_info <- rv$calculated_results$identified_columns
    id_col_name <- cols_info$id
    student_col_name <- cols_info$student

    validate(need(nrow(processed_df) >= 0, "Processed data frame is NULL or invalid."))
    validate(need(!is.na(student_col_name) && student_col_name %in% names(processed_df), "Student column not found in processed results."))

    numeric_id_rows_df <- processed_df
    if (!is.na(id_col_name) && id_col_name %in% names(processed_df) && id_col_name != "Student.ID.Placeholder") {
      id_values <- processed_df[[id_col_name]]
      is_numeric_id <- !is.na(suppressWarnings(as.numeric(as.character(id_values)))) &
        !is.na(id_values) &
        str_trim(as.character(id_values)) != ""
      numeric_id_rows_df <- processed_df[is_numeric_id, , drop = FALSE]
    } else {
      if(!is.na(id_col_name) && id_col_name != "Student.ID.Placeholder") {
        warning(paste("Cannot filter results by ID: ID column ('", id_col_name, "') not found or invalid. Proceeding without ID filter.", sep=""))
      }
    }

    final_filtered_df_unord <- numeric_id_rows_df %>%
      filter(tolower(.data[[student_col_name]]) != "points possible") %>%
      select(-any_of("adjusted"))

    validate(need(nrow(final_filtered_df_unord) > 0, "No student data remaining after filtering for numeric IDs and 'Points Possible' row."))

    desired_order <- rv$current_column_order
    current_cols <- colnames(final_filtered_df_unord)
    valid_order <- intersect(desired_order, current_cols)

    if (length(valid_order) == 0 || length(valid_order) != length(current_cols)) {
      warning("Stored column order was invalid or incomplete compared to available columns. Using default order of remaining columns.")
      final_filtered_df_ord <- final_filtered_df_unord
    } else {
      final_filtered_df_ord <- final_filtered_df_unord[, valid_order, drop = FALSE]
    }

    return(final_filtered_df_ord)
  })

  # --- Output for Verification Info (Unchanged) ---
  output$specialRowsInfoUI <- renderUI({
    req(rv$calculated_results$processed_marks, rv$calculated_results$identified_columns)
    processed_df <- rv$calculated_results$processed_marks
    cols_info <- rv$calculated_results$identified_columns
    id_col_name <- cols_info$id
    student_col_name <- cols_info$student

    validate(
      need(!is.null(processed_df), "Calculation results not yet available."),
      need(!is.null(cols_info), "Column info not available."),
      need(!is.na(student_col_name) && student_col_name %in% names(processed_df), "Student column missing in results.")
    )

    pp_row_calculated <- processed_df %>%
      filter(tolower(.data[[student_col_name]]) == "points possible")

    non_numeric_rows <- data.frame()
    if (!is.na(id_col_name) && id_col_name %in% names(processed_df) && id_col_name != "Student.ID.Placeholder") {
      id_values <- processed_df[[id_col_name]]
      is_numeric_id <- !is.na(suppressWarnings(as.numeric(as.character(id_values)))) &
        !is.na(id_values) &
        str_trim(as.character(id_values)) != ""
      non_numeric_rows <- processed_df %>%
        filter(!is_numeric_id & (tolower(.data[[student_col_name]]) != "points possible"))
    }

    special_rows_combined <- bind_rows(pp_row_calculated, non_numeric_rows)

    if (nrow(special_rows_combined) > 0) {
      main_table_cols <- tryCatch({ colnames(display_data()) }, error = function(e) NULL)
      output_content <- NULL

      if(is.null(main_table_cols) || length(main_table_cols) == 0) {
        main_table_cols <- rv$current_column_order
      }

      if(is.null(main_table_cols) || length(main_table_cols) == 0) {
        cols_to_show_fallback <- intersect(c(student_col_name, id_col_name, "calculated", "submitted"), names(special_rows_combined))
        cols_to_show_fallback <- cols_to_show_fallback[!is.na(cols_to_show_fallback)]

        if(length(cols_to_show_fallback) > 0) {
          df_to_show <- special_rows_combined[, cols_to_show_fallback, drop=FALSE]
          output_text <- paste(c("Could not determine main table columns. Showing basic info:",
                                   capture.output(print(df_to_show, row.names = FALSE))), collapse = "\n")
          output_content <- tags$pre(output_text)
        } else {
          output_content <- tags$pre("(No relevant basic columns found for special rows)")
        }
      } else {
        cols_to_show_actual <- intersect(main_table_cols, names(special_rows_combined))
        cols_to_show_actual <- cols_to_show_actual[!is.na(cols_to_show_actual)]

        if(length(cols_to_show_actual) > 0){
          df_to_show <- special_rows_combined %>% select(all_of(cols_to_show_actual))

          df_to_show_formatted <- df_to_show %>%
            mutate(across(where(is.numeric) & matches("^(HW|Test|Final_Score|calculated|maxFinal)$"), ~ sprintf("%.2f", round(., 2))),
                   across(where(is.numeric) & matches("^(submitted|Nhw|Ntest)$"), ~ sprintf("%.0f", round(., 0)))) %>%
            mutate(across(everything(), ~ ifelse(is.na(.), "", as.character(.))))

          # Check if knitr::kable exists
          if(exists("kable", where="package:knitr") && is.function(knitr::kable)) {
              output_text <- paste(capture.output(
                knitr::kable(df_to_show_formatted, format="simple", row.names = FALSE, align = 'l')
              ), collapse = "\n")
              output_content <- tags$pre(tags$code(output_text))
          } else {
              # Fallback if knitr isn't loaded or kable doesn't exist
              output_text <- paste(capture.output(print(df_to_show_formatted, row.names = FALSE)), collapse="\n")
              output_content <- tags$pre(tags$code(output_text))
              warning("knitr::kable not found, using basic print for verification info.")
          }
        } else {
          output_content <- tags$pre("(Could not determine relevant columns to display based on main table).")
        }
      }
      output_content
    } else {
      tags$pre("None (No 'Points Possible' row or non-numeric ID rows found in calculated results to display here).")
    }
  })


  # --- Render Raw Marks Preview Table (DT - Unchanged) ---
  output$rawMarksTable <- renderDT({
    validate( need(!is.null(rv$raw_data_preview), "Upload a valid CSV file to see the preview.") )
    if (ncol(rv$raw_data_preview) == 1 && colnames(rv$raw_data_preview)[1] == "Message") {
      validate(need(FALSE, rv$raw_data_preview$Message[1]))
    }
    # Check if DT::datatable exists
     if(exists("datatable", where="package:DT") && is.function(DT::datatable)) {
        DT::datatable( rv$raw_data_preview, rownames = FALSE, extensions = 'Buttons',
                  options = list( pageLength = 10, scrollX = TRUE, scrollY = "400px", searching = TRUE, paging = TRUE,
                                  dom = 'Bfrtip',
                                  buttons = list('copy', 'csv', 'excel', 'print') ),
                  caption = "Preview of uploaded data (Filtered Rows Removed; Columns Identified Post-Filtering)." )
     } else {
         # Fallback if DT not loaded
         renderPrint({ print(rv$raw_data_preview) })
         warning("DT::datatable not found, using basic print for raw preview.")
     }
  })

  # --- Render Processed Marks Interactive Table (DT - Unchanged) ---
  output$processedMarksTable <- renderDT({
    marks_to_show <- display_data()
    validate(need(!is.null(marks_to_show) && nrow(marks_to_show) > 0, "No processed marks with numeric IDs to display in table."))

    submitted_col_index <- which(colnames(marks_to_show) == "submitted")
    dt_order <- if (length(submitted_col_index) == 1) { list(list(submitted_col_index - 1, 'desc')) } else { list() }

    # Check if DT::datatable exists
    if(exists("datatable", where="package:DT") && is.function(DT::datatable)) {
        dt <- DT::datatable(marks_to_show, rownames = FALSE, extensions = c('Scroller'),
                      options = list( pageLength = 10, scrollX = TRUE, scrollY = "400px", deferRender = TRUE, scroller = TRUE,
                                      dom = 'frtip',
                                      order = dt_order
                      )
        )

        num_cols_format2 <- intersect(c("HW", "Test", "Final_Score", "calculated", "maxFinal"), names(marks_to_show))
        num_cols_format0 <- intersect(c("submitted", "Nhw", "Ntest"), names(marks_to_show))
        if(length(num_cols_format2) > 0) dt <- DT::formatRound(dt, columns = num_cols_format2, digits = 2)
        if(length(num_cols_format0) > 0) dt <- DT::formatRound(dt, columns = num_cols_format0, digits = 0)

        dt
    } else {
         renderPrint({ print(marks_to_show) })
         warning("DT::datatable not found, using basic print for processed marks table.")
    }
  })

  # --- Render Processed Marks Spreadsheet View (Handsontable - Unchanged) ---
  output$processedMarksSpreadsheet <- renderRHandsontable({
    marks_to_show <- display_data()
    validate(need(!is.null(marks_to_show) && nrow(marks_to_show) > 0, "No processed marks with numeric IDs to display in spreadsheet."))

    # Check if rhandsontable::rhandsontable exists
    if(exists("rhandsontable", where="package:rhandsontable") && is.function(rhandsontable::rhandsontable)) {
        hot <- rhandsontable::rhandsontable(
          marks_to_show,
          rowHeaders = NULL, readOnly = TRUE, stretchH = "all", height = 550,
          columnSorting = TRUE, manualColumnResize = TRUE, colWidths = 100
        )

        current_colnames <- colnames(marks_to_show)
        num_cols_format2 <- intersect(c("HW", "Test", "Final_Score", "calculated", "maxFinal"), current_colnames)
        num_cols_format0 <- intersect(c("submitted", "Nhw", "Ntest"), current_colnames)
        left_align_cols <- current_colnames[1:min(2, ncol(marks_to_show))]

        if(length(num_cols_format2) > 0) { hot <- rhandsontable::hot_cols(hot, format = "0.00", halign = "htRight", cols = num_cols_format2) }
        if(length(num_cols_format0) > 0) { hot <- rhandsontable::hot_cols(hot, format = "0", halign = "htRight", cols = num_cols_format0) }
        valid_left_align_cols <- intersect(left_align_cols, current_colnames)
        if(length(valid_left_align_cols) > 0) { hot <- rhandsontable::hot_cols(hot, halign = "htLeft", cols = valid_left_align_cols) }

        hot
    } else {
        # Fallback if rhandsontable not loaded
        renderPrint({ print(marks_to_show) })
        warning("rhandsontable::rhandsontable not found, using basic print for spreadsheet view.")
    }
  })

  # --- Download Handler for CSV with Notes (Adjusted for webR) ---
  output$downloadCsvWithNotes <- downloadHandler(
    filename = function() {
      req(input$markFile, cancelOutput = TRUE)
      in_basename <- basename(input$markFile$name)
      in_base_noext <- tools::file_path_sans_ext(in_basename)
      paste0(in_base_noext, "_processed_", format(Sys.time(), "%Y%m%d_%H%M"), ".csv")
    },
    content = function(file) {
      req(rv$calculation_params, rv$calculated_results$identified_columns)
      validate(need(tryCatch({ !is.null(display_data()) }, error = function(e) FALSE), "Calculation results needed."))
      data_to_export <- display_data()
      validate(need(!is.null(data_to_export) && nrow(data_to_export) > 0, "No data to export."))

      notes_text <- generate_notes_text(rv$calculation_params, rv$calculated_results$identified_columns)
      notes_lines <- strsplit(notes_text, "\n")[[1]]
      notes_df <- data.frame(CalculationNotes = notes_lines)

      # In webR/Shinylive, 'file' is often a connection or virtual path.
      # Using write.csv might be more straightforward.
      # Write data first
      write.csv(data_to_export, file, row.names = FALSE, na = "")
      # Append separator and notes (need careful handling of connections)
      write("\n", file, append = TRUE) # Separator line
      write.table(notes_df, file, append = TRUE, sep = ",", col.names = FALSE, row.names = FALSE, qmethod = "double", na = "")

    },
    contentType = "text/csv"
  )

  # --- Download Handler for Excel with Notes (Adjusted for webR) ---
  output$downloadXlsxWithNotes <- downloadHandler(
    filename = function() {
      req(input$markFile, cancelOutput = TRUE)
      in_basename <- basename(input$markFile$name)
      in_base_noext <- tools::file_path_sans_ext(in_basename)
      paste0(in_base_noext, "_processed_", format(Sys.time(), "%Y%m%d_%H%M"), ".xlsx")
    },
    content = function(file) {
      req(rv$calculation_params, rv$calculated_results$identified_columns)
      validate(need(tryCatch({ !is.null(display_data()) }, error = function(e) FALSE), "Calculation results needed."))
      data_to_export <- display_data()
      validate(need(!is.null(data_to_export) && nrow(data_to_export) > 0, "No data to export."))

      notes_text <- generate_notes_text(rv$calculation_params, rv$calculated_results$identified_columns)
      notes_lines <- strsplit(notes_text, "\n")[[1]]
      notes_df <- data.frame(Notes = notes_lines)

      sheets <- list(
        "Calculation Notes" = notes_df,
        "Processed Grades" = data_to_export
      )

      # Check if writexl::write_xlsx exists
      if(exists("write_xlsx", where="package:writexl") && is.function(writexl::write_xlsx)) {
          writexl::write_xlsx(sheets, path = file)
      } else {
          # Fallback if writexl not loaded - maybe write CSV instead?
          write.csv(data_to_export, file, row.names = FALSE, na = "")
          warning("writexl::write_xlsx not found. Exporting main data as CSV instead.")
          # Note: This changes the file extension expectation, which might confuse users.
          # A better fallback might be to disable the button if writexl isn't available.
      }
    },
    contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  )

  # --- Render Calculation Notes (for in-app display - Unchanged) ---
  output$processedMarksNotes <- renderUI({
    validate(need(!is.null(rv$calculation_params) && !is.null(rv$calculated_results$identified_columns),
                  "Calculate grades first to see parameters used and column definitions."))
    params <- rv$calculation_params;
    cols_info <- rv$calculated_results$identified_columns
    student_col_name_actual <- if(!is.null(cols_info) && !is.na(cols_info$student)) cols_info$student else "Student Col?"
    id_col_name_actual <- if(!is.null(cols_info) && !is.na(cols_info$id)) cols_info$id else "ID Col?"

    weights_str <- sprintf("HW=%.3f, Test=%.3f, Final=%.3f", params$weights["HW"], params$weights["Test"], params$weights["Final"])
    options_str <- sprintf("Fill HW=%s, Fill Test=%s, MaxFinal=%s", params$fill.hw, params$fill.test, params$final.only)
    omissions_str <- sprintf("Omit HW=%d, Omit Test=%d", params$n.omitted.hw, params$n.omitted.test)
    rules_display <- if (!is.null(params$adjustment_rules_string) && nzchar(str_trim(params$adjustment_rules_string))) {
      tagList( tags$li(tags$strong("Adjustment Rules String Used:")), tags$ul(style="margin-left: 20px;", tags$li(tags$code(params$adjustment_rules_string))) )
    } else { tags$li(tags$strong("Adjustments:"), " None applied.") }

    tagList(
      tags$p(tags$strong("Parameters Used:")),
      tags$ul(
        tags$li(paste("Weights (as decimals):", weights_str)),
        tags$li(paste("Options:", options_str)),
        tags$li(paste("Omissions:", omissions_str)),
        rules_display
      ),
      tags$hr(),
      tags$p(tags$strong("Column Definitions (in results table):")),
      tags$ul(
        tags$li(tags$code(student_col_name_actual), "/", tags$code(id_col_name_actual), ": Student identifiers."),
        tags$li(tags$code("Nhw"), "/", tags$code("Ntest"), ": # Submitted HW/Test (using only columns with valid Points Possible)."),
        tags$li(tags$code("HW"), "/", tags$code("Test"), ": Weighted component score %."),
        tags$li(tags$code("Final_Score"), ": Final Exam score %."),
        tags$li(tags$code("calculated"), ": Initial total % = Weighted(HW+Test+Final)."),
        tags$li(tags$code("maxFinal"), ": Max(calculated, Final_Score) if option checked."),
        tags$li(tags$code("submitted"), ": Final rounded grade % (capped at rule's upper bound or 99 overall).")
      ),
      tags$hr(),
      tags$p(tags$strong("Note on Displayed Table:"),
             " The main results table/spreadsheet above shows only rows where the identified ID column (", tags$code(id_col_name_actual), ") contains a numeric value and excludes the 'Points Possible' row.",
             " Calculated results for the 'Points Possible' row and rows with non-numeric IDs (which were included in the calculation but excluded from this table) are shown separately in the 'Verification Information' section above."
      )
    )
  })

  # --- Statistics Section (Unchanged) ---
  summary_data <- reactive({
    req(display_data())
    df_for_stats <- display_data()
    validate(need(nrow(df_for_stats) > 0, "No data available for statistics."),
             need("submitted" %in% names(df_for_stats), "Cannot find 'submitted' column for stats."),
             need(is.numeric(df_for_stats$submitted), "'submitted' column is not numeric."))
    scores <- as.numeric(df_for_stats$submitted)
    scores <- scores[!is.na(scores)]
    validate(need(length(scores) > 0, "No valid numeric 'submitted' scores found for stats."))
    scores
  })

  output$summaryStats <- renderPrint({
    scores <- summary_data(); n_obs <- length(scores)
    mean_val <- if (n_obs > 0) mean(scores, na.rm = TRUE) else NA
    median_val <- if (n_obs > 0) median(scores, na.rm = TRUE) else NA
    sd_val <- if (n_obs > 1) sd(scores, na.rm = TRUE) else NA
    iqr_val <- if (n_obs > 0) IQR(scores, na.rm = TRUE, type = 7) else NA
    se_val <- if (!is.na(sd_val) && n_obs > 0) sd_val / sqrt(n_obs) else NA
    min_val <- if(n_obs > 0) min(scores, na.rm = TRUE) else NA
    max_val <- if(n_obs > 0) max(scores, na.rm = TRUE) else NA

    cat("Summary Statistics ('submitted' grades from displayed table)\n")
    cat(rep("-", 80), "\n", sep="")
    cat(sprintf("N: %-6d      Mean: %-8.2f      Median: %-8.2f      Std Dev: %-7.2f\n",
                n_obs,
                ifelse(is.na(mean_val), NA, mean_val),
                ifelse(is.na(median_val), NA, median_val),
                ifelse(is.na(sd_val), NA, sd_val)))
    cat(sprintf("Min: %-6.1f      Max: %-9.1f      IQR: %-10.2f      Std Err: %-8.3f\n",
                ifelse(is.na(min_val), NA, min_val),
                ifelse(is.na(max_val), NA, max_val),
                ifelse(is.na(iqr_val), NA, iqr_val),
                ifelse(is.na(se_val), NA, se_val)))
    cat(rep("-", 80), "\n", sep="")

    if (n_obs > 0) {
      q_probs <- seq(0, 1, by = 0.1)
      q_vals <- quantile(scores, probs = q_probs, type = 7, na.rm = TRUE)
      q_names <- paste0(format(q_probs * 100, nsmall=0), "%")
      col_width <- 8
      q_labels_formatted <- sprintf(paste0("%-", col_width, "s"), q_names)
      q_values_formatted <- sprintf(paste0("%-", col_width, ".1f"), q_vals)
      cat("Quantiles:\n")
      cat("          ", paste(q_labels_formatted, collapse = ""), "\n")
      cat("          ", paste(q_values_formatted, collapse = ""), "\n")
    } else {
      cat("Quantiles: Not available (N=0)\n")
    }
    cat(rep("-", 80), "\n", sep="")
  })

  # --- Plots Section (Unchanged) ---
  output$distPlots <- renderPlot({
    scores <- summary_data();
    validate(need(length(scores) > 0, "No data to plot (after filtering for numeric IDs and PP row)."))
    df_plot <- data.frame(scores = scores)

    min_score <- 0; max_score <- 100; bin_width <- 10
    breaks <- seq(min_score, max_score, by = bin_width)
    axis_max <- max_score

    p1 <- ggplot(df_plot, aes(x = scores)) +
      geom_histogram(aes(y = after_stat(count)), breaks = breaks, fill = "#56B4E9", color = "white", closed = "left", boundary=0) +
      stat_bin(aes(y = after_stat(count), label = ifelse(after_stat(count) > 0, after_stat(count), "")),
               geom = "text", vjust = -0.5, size = 3.5, breaks = breaks, closed = "left", boundary=0) +
      scale_x_continuous(name = "Submitted Score ", breaks = breaks, limits = c(min_score, axis_max)) +
      scale_y_continuous(name = "Frequency", expand = expansion(mult = c(0.01, 0.1))) +
      labs(title = "Grade Distribution ('submitted' from displayed table)") +
      theme_minimal(base_size = 12) +
      theme(plot.title = element_text(hjust = 0.5))

    p2 <- ggplot(df_plot, aes(x = scores)) +
      stat_ecdf(geom = "step", pad = FALSE, color = "#0072B2", linewidth = 1) +
      scale_y_continuous(name = "Cumulative %", breaks = seq(0, 1, by = 0.1), labels = scales::percent_format(accuracy=1)) +
      scale_x_continuous(name = "Submitted Score ", breaks = seq(0, 100, by = 10), limits = c(min_score, axis_max)) +
      labs(title = "ECDF ('submitted' from displayed table)") +
      theme_minimal(base_size = 12) +
      theme(panel.grid.major = element_line(colour = "grey92"),
            panel.grid.minor = element_blank(),
            plot.title = element_text(hjust = 0.5))

    # Check if patchwork::`+` exists
    if(exists("+", where="package:patchwork") && is.function(patchwork::`+`)) {
        p1 + p2
    } else {
        # Fallback if patchwork not loaded
        gridExtra::grid.arrange(p1, p2, ncol=2) # Requires gridExtra
        warning("patchwork not found, attempting to use gridExtra for plot layout.")
    }
  }, res = 96)

} # End server function

# --- Run the application ---
shinyApp(ui = ui, server = server)

    </script>

    <div id="shinylive-app-container"></div>

    <script>
      // Optional: Remove loading indicator once Shinylive might have started loading
      // A more robust solution would involve Shinylive's events if available
      window.addEventListener('load', () => {
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
          // Maybe hide it after a short delay, assuming Shinylive takes over
          setTimeout(() => { loadingIndicator.style.display = 'none'; }, 2000);
        }
      });
    </script>

</body>
</html>
