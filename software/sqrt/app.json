[{"name":"app.R","content":"library(munsell)\nlibrary(shiny)\nlibrary(rhandsontable)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(latex2exp)\nlibrary(ggplot2)\nlibrary(grid)\n\n# Function to compute square root using Newton's Method (now includes slope)\nnewton_sqrt <- function(S, x0 = S / 2, tol = 1e-3) {\n    if (S < 0) stop(\"Square root of a negative number is not defined for real numbers.\")\n    \n    x_n <- x0\n    trace <- data.frame(x_i = x_n, y = x_n^2 - S, slope = 2 * x_n) # Store initial point and slope\n    \n    repeat {\n        x_next <- 0.5 * (x_n + S / x_n) # Newton's update formula\n        trace <- rbind(trace, data.frame(x_i = x_next, y = x_next^2 - S, slope = 2 * x_next))\n        \n        if (abs(x_next - x_n) < tol) {\n            result <- x_next\n            attr(result, \"trace\") <- trace\n            attr(result, \"error\") <- abs(x_next - sqrt(S))\n            attr(result, \"x\") <- S\n            return(result)\n        }\n        x_n <- x_next\n    }\n}\n\n# Function to compute tangent lines\ncompute_tangent <- function(x0, y0, slope, xrange = c(-10, 10)) {\n    x_vals <- seq(xrange[1], xrange[2], length.out = 100)\n    y_vals <- y0 + slope * (x_vals - x0)\n    data.frame(x = x_vals, y = y_vals)\n}\n\n# Function to compute square root using Newton's Method\n# Function to display results in a table (updated to use new trace structure)\ndisplay_table <- function(results) {\n    numbers <- sapply(results, function(r) attr(r, \"x\"))\n    true_values <- round(sapply(results, function(r) sqrt(attr(r, \"x\"))), 5)\n    approximations <- round(sapply(results, function(r) tail(attr(r, \"trace\")$x_i, 1)), 5)\n    errors <- round(sapply(results, function(r) attr(r, \"error\")), 5)\n\n    table_data <- data.frame(\n        \"\\\\(S\\\\)\" = numbers,\n        \"Newton-\\\\(\\\\sqrt{S}\\\\)\" = approximations,\n        \"R-\\\\(\\\\sqrt{S}\\\\)\" = true_values,\n        Error = errors,\n        check.names = FALSE\n    )\n\n    kable(table_data, format = \"html\", escape = FALSE) %>%\n        kable_styling(bootstrap_options = c(\"striped\", \"hover\", \"condensed\", \"responsive\")) %>%\n        column_spec(1, width = \"5em\") %>%\n        column_spec(2, width = \"8em\") %>%\n        column_spec(3, width = \"8em\") %>%\n        column_spec(4, width = \"8em\") %>%\n        row_spec(0, bold = TRUE)\n}\n\n# Function to plot all iteration traces in a single plot (updated to extract trace)\nplot_traces_single <- function(results) {\n    # Extract all traces\n    traces_list <- lapply(results, function(r) attr(r, \"trace\")$x_i)\n    max_len <- max(sapply(traces_list, length))\n\n    # Pad shorter traces with NA to match longest iteration length\n    traces_padded <- lapply(traces_list, function(trace) {\n        length(trace) <- max_len\n        trace\n    })\n\n    # Convert to matrix for plotting\n    traces_matrix <- do.call(cbind, traces_padded)\n\n    line_types <- rep(1:10, 5)\n    matplot(1:max_len, traces_matrix,\n        type = \"b\", col = rainbow(length(traces_padded)),\n        lty = line_types[1:length(traces_padded)], lwd = 2,\n        pch = 16, cex = 1.2,\n        xlab = \"Iteration\", ylab = \"Approximation\",\n        main = TeX(\"Traces of Approximating \\\\sqrt{S}\")\n    )\n\n    # Add legend with correct labels\n    x_values <- sapply(results, function(r) attr(r, \"x\"))\n    trace_labels <- sapply(x_values, function(x) TeX(paste0(\"\\\\sqrt{\", x, \"}\")))\n    legend(\"topright\",\n        legend = trace_labels, col = rainbow(length(traces_padded)),\n        lty = line_types[1:length(traces_padded)], pch = 16\n    )\n}\n\n# # Function to generate Newton's method animation using newton_sqrt output\n# generate_animation <- function(S, x0, gif_path) {\n#     result <- newton_sqrt(S, x0) # Run Newton's method\n#     trace <- attr(result, \"trace\") # Extract iteration trace\n# \n#     f <- function(x) x^2 - S\n#     x_range <- seq(min(trace$x_i) - 1, max(trace$x_i) + 1, length.out = 100)\n#     df_func <- data.frame(x = x_range, y = f(x_range))\n# \n#     # Compute tangent lines for each iteration\n#     tangent_data <- data.frame()\n#     for (i in 1:nrow(trace)) {\n#         tangent_df <- compute_tangent(trace$x_i[i], trace$y[i], trace$slope[i], xrange = range(x_range))\n#         tangent_df$iter <- i\n#         tangent_data <- rbind(tangent_data, tangent_df)\n#     }\n# \n#     p <- ggplot() +\n#         geom_line(data = df_func, aes(x = x, y = y), color = \"blue\", size = 1.2) +\n#         geom_hline(yintercept = 0, linetype = \"dashed\") +\n#         geom_point(data = trace, aes(x = x_i, y = 0), color = \"red\", size = 3) +\n#         geom_segment(data = trace, aes(x = x_i, y = y, xend = x_i, yend = 0), color = \"purple\", linetype = \"dotted\") +\n#         geom_line(data = tangent_data, aes(x = x, y = y, group = iter), color = \"deeppink\", size = 1.2, linetype = \"solid\") +\n#         labs(title = \"Newton's Method for sqrt(S): Iteration {frame_time}\", x = \"x\", y = \"f(x) = x² - S\") +\n#         theme_minimal() +\n#         transition_time(iter)\n# \n#     # Save animation as GIF\n#     anim_save(gif_path, animate(p, renderer = gifski_renderer(), fps = 2, duration = 5, width = 600, height = 400))\n# }\n\nui <- fluidPage(\n    tags$head(\n        tags$script(src = \"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML\")\n    ),\n    withMathJax(),\n    titlePanel(\"Newton's Method for Finding Square Roots\"),\n    h3(\"\\\\(\\\\sqrt{S}\\\\) Calculator\"),\n    # Titles side-by-side at the top\n    fluidRow(\n        column(3, h3(\"\\\\(S\\\\) and \\\\(x_0\\\\)(editable)\")),\n        column(6, h3(\"Results of Computing \\\\(\\\\sqrt{S}\\\\)\"))\n    ),\n\n    # Sidebar + Main Panel (Both aligned under titles)\n    fluidRow(\n        column(\n            3,\n            rHandsontableOutput(\"input_table\"), # Editable table\n            actionButton(\"clearTable\", \"Clear Table\"), # Reset table button\n            selectInput(\"tol\", \"Select termination tolerence:\",\n                choices = c(\"10\" = 10, \"1\" = 1, \"0.1\" = 0.1, \"0.01\" = 0.01, \"0.001\" = 0.001),\n                selected = 0.001\n            )\n        ),\n        column(\n            6,\n            uiOutput(\"result_table\") # Displays numerical results table\n        )\n    ),\n\n    # Convergence plot placed at the bottom spanning both panels\n    fluidRow(\n        column(9, plotOutput(\"convergence_plot\"))\n    ),\n    h3(\"Newton's Method Explained\"),\n    withMathJax(HTML(\"\n        <p>Newton’s method is an iterative process used to find the roots of a function. Given a function \\\\( f(x) \\\\), Newton's iteration formula is \\\\( x_{n+1} = x_n - \\\\frac{f(x_n)}{f'(x_n)} \\\\). To compute the square root of \\\\( S \\\\), we define \\\\( f(x) = x^2 - S \\\\). The derivative of \\\\( f(x) \\\\) is \\\\( f'(x) = 2x \\\\). Substituting these into Newton's formula yields \\\\( x_{n+1} = x_n - \\\\frac{x_n^2 - S}{2x_n} \\\\). Simplifying:<\/p>\n        $$ x_{n+1} = \\\\frac{1}{2} \\\\left( x_n + \\\\frac{S}{x_n} \\\\right) $$\n\n    \")),\n\n    # Input fields for S and x0 displayed side-by-side\n    h4(\"Typing your own \\\\(S\\\\) and \\\\(x_0\\\\) to visualize the iterations:\"),\n    fluidRow(\n        column(2, offset = 2, div(style = \"margin-bottom: 10px;\", numericInput(\"example_S\", \"\\\\(S\\\\):\", value = 25, min = 1))),\n        column(2, div(style = \"margin-bottom: 10px;\", numericInput(\"example_x0\", \"\\\\(x_0\\\\):\", value = 2, min = 1)))\n    ),\n    fluidRow(\n        column(\n            4, # Left: Iterations Section\n            h4(\"Iterations:\"),\n            uiOutput(\"iterations\") # Auto-generated steps\n        ),\n        column(\n            6, # Right: Animation with Controls\n            h4(\"Animation:\"),\n            fluidRow(\n                column(1, actionButton(\"prev_step\", \"<\")), # Move backward\n                column(1, actionButton(\"next_step\", \">\")) # Move forward\n            ),\n            plotOutput(\"newton_animation\", height = \"400px\", click = \"newton_animation_click\") # Display animation beside text\n        )\n    ),\n    div(\n        style = \"margin-top: 30px; text-align: center; font-size: 14px;\",\n        HTML(\"<hr> Author: <strong>Longhai Li<\/strong><br>\n              Department of Mathematics and Statistics, University of Saskatchewan<br>\n              <a href='https://longhaisk.github.io' target='_blank'>https://longhaisk.github.io<\/a>\")\n    )\n)\n\n# Shiny Server\nserver <- function(input, output) {\n    input_data <- reactiveValues(\n        data = data.frame(S = c(2, 5, 7, 8, 9, 11), x0 = c(1, 2.5, 3.5, 4, 4.5, 5.5)))\n\n    observeEvent(input$clearTable, {\n        input_data$data <- data.frame(S = rep(0, 6), x0 = rep(1, 6))\n    })\n    output$input_table <- renderRHandsontable({\n        req(input_data$data)\n        rhandsontable(input_data$data, colHeaders = c(\"\\\\(S\\\\)\", \"\\\\(x_0\\\\)\"))\n    })\n    observeEvent(input$input_table$data, {\n        if (!is.null(input$input_table$data)) {\n            input_data$data <- hot_to_r(input$input_table)\n        }\n    })\n    \n    results <- reactive({\n        req(input_data$data)\n        data <- input_data$data\n        numbers <- data$S\n        initial_values <- data$x0\n        valid_rows <- !is.na(numbers) & numbers >= 0 & !is.na(initial_values) & initial_values > 0\n        numbers <- numbers[valid_rows]\n        initial_values <- initial_values[valid_rows]\n        mapply(newton_sqrt, numbers, initial_values, tol = as.numeric(input$tol), SIMPLIFY = FALSE)\n    })\n\n    output$result_table <- renderUI({\n        req(results())\n        HTML(display_table(results()))\n    })\n\n    output$convergence_plot <- renderPlot({\n        req(results())\n        plot_traces_single(results())\n    })\n\n\n    # Compute Newton iterations reactively\n    newton_results <- reactive({\n        newton_sqrt(input$example_S, input$example_x0, tol = 0.001)\n    })\n\n    # Store the current iteration index\n    current_step <- reactiveVal(1)\n\n    # Reset step when S or x0 changes\n    observeEvent(input$example_S,\n        {\n            current_step(1)\n        },\n        ignoreInit = TRUE\n    )\n    observeEvent(input$example_x0,\n        {\n            current_step(1)\n        },\n        ignoreInit = TRUE\n    )\n\n    # Display Iteration 0 (Initial Guess)\n\n\n    # Dynamically generate iteration steps and highlight the active one\n    output$iterations <- renderUI({\n        trace <- attr(newton_results(), \"trace\")$x_i\n        step <- current_step() # Get the current animation step\n\n        # Handle Iteration 0 separately to avoid duplication\n        merged_text <- paste0(\n            \"<p style='line-height: 3;\", if (step == 1) \" color: red; font-weight: bold;'\" else \"'>\",\n            \"<strong>Iteration 0:<\/strong> \\\\( x_0 = \", round(trace[1], 5), \" \\\\)<\/p>\"\n        )\n\n        # Loop for Iterations 1, 2, ..., n\n        merged_text <- paste0(\n            merged_text,\n            paste(\n                sapply(1:(length(trace) - 1), function(i) {\n                    paste0(\n                        \"<p style='line-height: 3;\", if (i == step - 1) \" color: red; font-weight: bold;'\" else \"'>\",\n                        \"<strong>Iteration \", i, \":<\/strong> \\\\( x_\", i,\n                        \" = \\\\frac{1}{2} \\\\left( \", round(trace[i], 5),\n                        \" + \\\\dfrac{\", input$example_S, \"}{\", round(trace[i], 5), \"} \\\\right) \\\\approx \",\n                        round(trace[i + 1], 5), \" \\\\)<\/p>\"\n                    )\n                }),\n                collapse = \"\"\n            )\n        )\n\n        withMathJax(HTML(merged_text))\n    })\n    # Move forward when \"Next Step\" is clicked\n    observeEvent(input$next_step, {\n        trace <- attr(newton_results(), \"trace\")$x_i\n        if (current_step() < length(trace)) {\n            current_step(current_step() + 1) # Move to next step\n        }\n    })\n\n    # Move backward when \"Previous Step\" is clicked\n    observeEvent(input$prev_step, {\n        if (current_step() > 1) {\n            current_step(current_step() - 1) # Move to previous step\n        }\n    })\n\n    # Render the animation for the current step\n\n    \n    output$newton_animation <- renderPlot({\n        # Get the iteration trace (only x_i values) from newton_results()\n        trace <- attr(newton_results(), \"trace\")$x_i\n        # current_step() is 1-indexed; label for the plot should be (current_step() - 1)\n        step <- current_step()\n        iter_label <- step - 1 # Label for the plot (e.g., if step==1, label = 0)\n        \n        # Current x value at the iteration\n        x_i <- trace[step]\n        \n        # Define the function f(x) = x^2 - S\n        f <- function(x) x^2 - input$example_S\n        \n        # Expand the x_range to include some negative values\n        x_range <- seq(min(min(trace) - 1, -2), max(trace) + 1, length.out = 100)\n        df_func <- data.frame(x = x_range, y = f(x_range))\n        \n        # Compute a fixed y-range based solely on f(x)\n        y_min <- min(df_func$y)\n        y_max <- max(df_func$y)\n        \n        # Compute the tangent line at the current iteration\n        slope <- 2 * x_i\n        tangent_x <- seq(min(x_range), max(x_range), length.out = 100)\n        tangent_y <- f(x_i) + slope * (tangent_x - x_i)\n        df_tangent <- data.frame(x = tangent_x, y = tangent_y)\n        \n        # Create a LaTeX label for x_i using latex2exp (label shows x_{iter_label})\n        label_expr <- TeX(paste0(\"$x_{\", iter_label, \"}$\"))\n        \n        # Get the plotting area range based on ggplot limits\n        plot_x_min <- min(x_range)\n        plot_x_max <- max(x_range)\n        \n        # Find the maximum y-value within the plotting area (x_min, x_max)\n        visible_x_range <- seq(plot_x_min, plot_x_max, length.out = 100)\n        visible_y_values <- f(visible_x_range)\n        max_y_index <- which.max(visible_y_values)\n        max_x <- visible_x_range[max_y_index]\n        max_y <- visible_y_values[max_y_index]\n        \n        # Build the plot\n        ggplot() +\n            geom_line(data = df_func, aes(x = x, y = y), color = \"blue\", size = 1.2) +\n            geom_hline(yintercept = 0, linetype = \"dashed\") +\n            geom_point(aes(x = x_i, y = 0), color = \"red\", size = 3) +\n            geom_segment(aes(x = x_i, y = f(x_i), xend = x_i, yend = 0),\n                         color = \"purple\", linetype = \"dotted\"\n            ) +\n            geom_line(\n                data = df_tangent, aes(x = x, y = y),\n                color = \"deeppink\", size = 1.2, linetype = \"solid\"\n            ) +\n            geom_text(aes(x = x_i, y = -1),\n                      label = label_expr,\n                      size = 6, vjust = 1.5\n            ) +\n            labs(\n                title = TeX(sprintf(\"Iteration %d: $x_{%d}$ = %.4f\", iter_label, iter_label, x_i)),\n                x = \"x\",\n                y = TeX(\"$f(x) = x^2 - S$\")\n            ) +\n            scale_y_continuous(limits = c(y_min - 1, y_max + 1)) +\n            theme_minimal() +\n            \n            # Add the LaTeX y-label \"f(x) = x^2 - S\" inside the plot with an arrow\n            annotation_custom(\n                grob = textGrob(TeX(\"$f(x) = x^2 - S$\"), gp = gpar(fontsize = 12, col = \"black\")),\n                xmin = min(x_range) + 0.5, ymin = y_max * 0.85\n            ) +\n            \n            # Add an arrow pointing to the maximum of f(x) (blue color)\n            annotation_custom(\n                grob = linesGrob(\n                    x = unit(c(min(x_range) + 0.5, max_x), \"native\"),\n                    y = unit(c(y_max * 0.85, max_y), \"native\"),\n                    gp = gpar(col = \"blue\", lwd = 1, arrow = arrow(type = \"closed\", length = unit(0.15, \"inches\")))\n                )\n            )\n    })\n    \n}\n\nshinyApp(ui, server)\n","type":"text"}]
