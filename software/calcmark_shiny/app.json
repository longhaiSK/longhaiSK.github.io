[{"name":"app.R","content":"# --- Load Libraries ---\n# Ensure these packages are installed:\n# install.packages(c(\"shiny\", \"tidyverse\", \"DT\", \"rhandsontable\", \"shinyjs\",\n#                    \"shinyWidgets\", \"ggplot2\", \"scales\", \"shinythemes\", \"shinyBS\",\n#                    \"lubridate\", \"knitr\", \"patchwork\", \"sortable\", \"writexl\", \"tools\"))\nlibrary(munsell)\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(bslib)\n#library(tidyverse) # Includes dplyr, stringr, readr, ggplot2, tidyr\nlibrary(DT)        # For interactive tables\nlibrary(rhandsontable) # For spreadsheet view\nlibrary(shinyjs)   # Optional, but potentially useful\nlibrary(shinyWidgets) # Optional, for potentially nicer inputs\nlibrary(ggplot2)   # For plotting (loaded via tidyverse)\nlibrary(scales)    # For plot scales (like percent)\nlibrary(shinythemes) # Optional: for theme\nlibrary(shinyBS)   # Required for popovers/tooltips\nlibrary(lubridate) # For date formatting (Sys.Date())\nlibrary(knitr)     # For formatting tables as text\nlibrary(patchwork) # For combining plots\nlibrary(sortable)  # For rank_list\nlibrary(writexl)   # For creating Excel files in download handler\nlibrary(tools)     # For file_path_sans_ext\n\n# --- Helper Functions ---\n# maxmean remains the same\nmaxmean <- function(x, n) {\n  x_numeric <- suppressWarnings(as.numeric(x))\n  x_numeric <- x_numeric[!is.na(x_numeric)]\n  if (length(x_numeric) == 0) return(NA_real_)\n  n <- max(1, min(length(x_numeric), floor(n))) # Ensure n is valid\n  mean(sort(x_numeric, decreasing = TRUE)[1:n], na.rm = TRUE)\n}\n\n# identify_columns now takes df and performs PP row check\nidentify_columns <- function(df) {\n  # Input validation\n  if (!is.data.frame(df) || nrow(df) < 2) {\n    stop(\"Input must be a data frame with at least 2 rows (including Points Possible).\")\n  }\n  col_names <- colnames(df)\n  \n  # 1. Identify Student Column (Name only)\n  student_col <- grep(\"^Student\", col_names, value = TRUE, ignore.case = TRUE)[1]\n  if (is.na(student_col) || !student_col %in% col_names) {\n    stop(\"Cannot identify 'Student' column based on name pattern '^Student'.\")\n  }\n  \n  # 2. Find Points Possible Row Index\n  student_vector <- df[[student_col]]\n  points_possible_row_idx <- which(tolower(student_vector) == \"points possible\")\n  if (length(points_possible_row_idx) != 1) {\n    stop(\"Could not find exactly one 'Points Possible' row in the '\", student_col, \"' column.\")\n  }\n  \n  # 3. Initial Identification by Name Pattern\n  hw_cols_potential <- str_subset(col_names, regex(\"^(HW|A)\", ignore_case = TRUE))\n  test_cols_potential <- str_subset(col_names, regex(\"^(Test|Midterm)\", ignore_case = TRUE))\n  final_col_potential <- str_subset(col_names, regex(\"^Final\", ignore_case = TRUE))\n  potential_mark_cols <- unique(c(hw_cols_potential, test_cols_potential, final_col_potential))\n  \n  # 4. Filter Mark Columns based on Numeric PP Row Value\n  cols_to_keep <- c()\n  if (length(potential_mark_cols) > 0) {\n    # Ensure potential columns actually exist before trying to access them\n    potential_mark_cols_exist <- intersect(potential_mark_cols, col_names)\n    if (length(potential_mark_cols_exist) > 0) {\n      pp_values <- df[points_possible_row_idx, potential_mark_cols_exist, drop = FALSE]\n      for (col_name in potential_mark_cols_exist) {\n        raw_value <- pp_values[[col_name]]\n        # Check if not missing/empty and is convertible to number\n        is_valid_numeric <- !is.null(raw_value) &&\n          !is.na(raw_value) &&\n          !(is.character(raw_value) && str_trim(raw_value) == \"\") &&\n          !is.na(suppressWarnings(as.numeric(raw_value)))\n        \n        if (is_valid_numeric) {\n          cols_to_keep <- c(cols_to_keep, col_name)\n        }\n      }\n    }\n  }\n  \n  # 5. Create Final Filtered Lists\n  hw_cols_final <- intersect(hw_cols_potential, cols_to_keep)\n  test_cols_final <- intersect(test_cols_potential, cols_to_keep)\n  # Handle final column slightly differently - expect only one candidate after filtering\n  final_col_candidates <- intersect(final_col_potential, cols_to_keep)\n  final_col_final <- if (length(final_col_candidates) == 1) final_col_candidates else NA_character_\n  \n  # 6. Identify ID Column (Name only)\n  id_col <- NA_character_ # Default to NA\n  sis_user_id_match_idx <- which(tolower(col_names) == \"sis user id\")\n  if (length(sis_user_id_match_idx) > 0) {\n    id_col <- col_names[sis_user_id_match_idx[1]]\n  } else {\n    alt_id_matches <- grep(\"^ID$|^Student[._ ]?ID$\", col_names, value = TRUE, ignore.case = TRUE)\n    if (length(alt_id_matches) > 0) {\n      id_col <- alt_id_matches[1]\n    }\n  }\n  \n  # 7. Return final list\n  final_mark_cols = unique(c(hw_cols_final, test_cols_final, final_col_final))\n  final_mark_cols = final_mark_cols[!is.na(final_mark_cols)] # Remove NA from final col if needed\n  \n  list(\n    hw = hw_cols_final,\n    test = test_cols_final,\n    final = final_col_final, # Could be NA if not exactly one valid found\n    student = student_col,\n    id = id_col,              # Could be NA\n    marks = final_mark_cols   # Contains only cols that passed name AND PP numeric check\n  )\n}\n\n# parse_adjustment_rules remains the same\nparse_adjustment_rules <- function(rules_string) {\n  if (is.null(rules_string) || str_trim(rules_string) == \"\") { return(list()) }\n  rules_parts <- str_split(rules_string, \";\")[[1]]\n  parsed_rules <- list(); rule_index <- 1\n  for (part in rules_parts) {\n    part <- str_trim(part); if (part == \"\") next\n    match <- str_match(part, \"^\\\\[\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)\\\\s*,\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)\\\\s*\\\\]\\\\s*:\\\\s*(-?\\\\d+(?:\\\\.\\\\d+)?)\\\\s*$\")\n    if (is.na(match[1, 1])) { stop(paste0(\"Invalid format in rule #\", rule_index, \": '\", part, \"'.\")) }\n    lower_b <- suppressWarnings(as.numeric(match[1, 2])); upper_b <- suppressWarnings(as.numeric(match[1, 3])); mark_add <- suppressWarnings(as.numeric(match[1, 4]))\n    if (is.na(lower_b) || is.na(upper_b) || is.na(mark_add)) { stop(paste0(\"Non-numeric value found in rule #\", rule_index, \": '\", part, \"'\")) }\n    if (lower_b >= upper_b) { stop(paste0(\"Lower bound (\", lower_b, \") must be < Upper bound (\", upper_b, \") in rule #\", rule_index)) }\n    parsed_rules[[length(parsed_rules) + 1]] <- list(lower = lower_b, upper = upper_b, added = mark_add); rule_index <- rule_index + 1\n  }\n  return(parsed_rules)\n}\n\n# --- Helper Function: Generate Notes as Plain Text (Includes Credit Line) ---\ngenerate_notes_text <- function(params, cols_info) {\n  if (is.null(params) || is.null(cols_info)) {\n    return(\"Calculation parameters or column information not available.\")\n  }\n  \n  student_col_name_actual <- if(!is.na(cols_info$student)) cols_info$student else \"Student Col?\"\n  id_col_name_actual <- if(!is.na(cols_info$id)) cols_info$id else \"ID Col?\"\n  \n  weights_str <- sprintf(\"Weights (as decimals): HW=%.3f, Test=%.3f, Final=%.3f\", params$weights[\"HW\"], params$weights[\"Test\"], params$weights[\"Final\"])\n  options_str <- sprintf(\"Options: Fill HW=%s, Fill Test=%s, MaxFinal=%s\", params$fill.hw, params$fill.test, params$final.only)\n  omissions_str <- sprintf(\"Omissions: Omit HW=%d, Omit Test=%d\", params$n.omitted.hw, params$n.omitted.test)\n  rules_display <- if (!is.null(params$adjustment_rules_string) && nzchar(str_trim(params$adjustment_rules_string))) {\n    sprintf(\"Adjustment Rules String Used: %s\", params$adjustment_rules_string)\n  } else {\n    \"Adjustments: None applied.\"\n  }\n  \n  col_defs <- paste(\n    \"Column Definitions (in results table):\",\n    paste0(\"  \", student_col_name_actual, \"/\", id_col_name_actual, \": Student identifiers.\"),\n    paste0(\"  Nhw/Ntest: # Submitted HW/Test (using only columns with valid Points Possible).\"),\n    paste0(\"  HW/Test: Weighted component score %.\"),\n    paste0(\"  Final_Score: Final Exam score %.\"),\n    paste0(\"  calculated: Initial total % = Weighted(HW+Test+Final).\"),\n    paste0(\"  maxFinal: Max(calculated, Final_Score) if option checked.\"),\n    paste0(\"  submitted: Final rounded grade % (capped at rule's upper bound or 99 overall).\"),\n    sep = \"\\n\"\n  )\n  \n  display_note <- paste(\n    \"Note on Exported Table:\",\n    paste0(\"  The following table shows only rows where the identified ID column (\", id_col_name_actual, \") contains a numeric value and excludes the 'Points Possible' row.\"),\n    paste0(\"  Calculated results for the 'Points Possible' row and rows with non-numeric IDs are shown separately in the 'Verification Information' section within the app.\"),\n    sep = \"\\n\"\n  )\n  \n  # Credit Line\n  app_credit_line <- \"This file is made by https://longhai.shinyapps.io/marks/\"\n  \n  # Combine all parts into a single string\n  paste(\n    \"--- Calculation Notes ---\",\n    \"Parameters Used:\",\n    paste0(\"  \", weights_str),\n    paste0(\"  \", options_str),\n    paste0(\"  \", omissions_str),\n    paste0(\"  \", rules_display),\n    \"---\",\n    col_defs,\n    \"---\",\n    display_note,\n    \"---\",\n    app_credit_line, # Added the credit line here\n    \"---\",\n    \"\", # Add an empty line before the table data\n    sep = \"\\n\"\n  )\n}\n\n\n# --- Core Calculation Function (Unchanged) ---\n#' @throws Error if essential columns ('Final') are missing/invalid after identification.\ncalculate_grades <- function(df, params) {\n  df_original <- df # Keep original for raw display prep later\n  \n  # --- Use identify_columns (performs name and PP numeric checks) ---\n  cols <- identify_columns(df)\n  \n  # --- Basic Setup & Validation ---\n  # Handle ID column (add placeholder if NA)\n  if (is.na(cols$id)) {\n    cols$id <- \"Student.ID.Placeholder\"; if (!cols$id %in% colnames(df)) df[[cols$id]] <- NA\n    warning(\"Could not identify Student ID column ('SIS User ID', 'ID', 'Student ID'). Using placeholder.\")\n  } else if (!cols$id %in% colnames(df)) {\n    stop(paste(\"Identified ID column '\", cols$id, \"' not found in data frame.\", sep=\"\"))\n  }\n  \n  # Validate essential Final column\n  if (is.na(cols$final) || length(cols$final) != 1) {\n    final_col_potential_names <- str_subset(colnames(df_original), regex(\"^Final\", ignore_case = TRUE))\n    stop(paste(\"Could not identify exactly one 'Final' column that also has a numeric 'Points Possible' value. Potential names found based on pattern:\", paste(final_col_potential_names, collapse=\", \")))\n  }\n  \n  # Validate that *some* mark columns remain\n  if (length(cols$marks) == 0) {\n    stop(\"No mark columns (HW*, Test*, Final*) remain after checking name patterns and 'Points Possible' row values.\")\n  }\n  \n  # --- Get PP row index ---\n  points_possible_row_idx <- which(tolower(df[[cols$student]]) == \"points possible\")\n  valid_mark_cols <- cols$marks\n  \n  # --- Data Cleaning & Percentage Calculation ---\n  marks_processed <- df %>%\n    mutate(across(all_of(valid_mark_cols), as.character)) %>%\n    mutate(across(all_of(valid_mark_cols), ~ suppressWarnings(as.numeric(.)))) %>%\n    mutate(across(all_of(valid_mark_cols), ~ replace_na(., 0)))\n  \n  # Extract Points Possible values *only for the valid columns*\n  points_possible <- as.numeric(marks_processed[points_possible_row_idx, valid_mark_cols])\n  if (any(is.na(points_possible))) {\n    stop(\"Internal Error: NA values found in 'Points Possible' row for columns previously identified as valid.\")\n  }\n  if (any(points_possible <= 0)) {\n    invalid_pp_cols <- valid_mark_cols[points_possible <= 0]\n    warning(paste(\"Non-positive values found in 'Points Possible' row for identified columns:\", paste(invalid_pp_cols, collapse=\", \"), \". Calculations might be affected. Consider correcting the CSV.\"))\n  }\n  points_possible_map <- setNames(points_possible, valid_mark_cols)\n  \n  # --- Keep ALL rows (including PP) for calculation ---\n  students_df <- marks_processed %>%\n    select(all_of(c(cols$student, cols$id, valid_mark_cols)))\n  \n  # Handle case where df might be empty except PP row\n  if (nrow(students_df) == 0) {\n    warning(\"Data frame became empty unexpectedly during processing.\")\n    final_output_cols <- c(cols$student, cols$id, \"Nhw\", \"HW\", \"Ntest\", \"Test\", \"Final_Score\", \"calculated\", \"maxFinal\", \"adjusted\", \"submitted\")\n    empty_results <- data.frame(matrix(ncol = length(final_output_cols), nrow = 0))\n    colnames(empty_results) <- final_output_cols\n    raw_marks_display_internal_empty <- df_original[0, ]\n    return(list(processed_marks = empty_results, raw_marks_display = raw_marks_display_internal_empty, identified_columns = cols))\n  }\n  \n  # Calculate percentage scores\n  for (col in valid_mark_cols) {\n    if (col %in% names(students_df) && !is.null(points_possible_map[[col]]) && points_possible_map[[col]] != 0) {\n      students_df[[col]] <- (students_df[[col]] / points_possible_map[[col]]) * 100\n    } else { students_df[[col]] <- 0 }\n  }\n  \n  # --- Apply Fill Options ---\n  if (cols$final %in% names(students_df)) {\n    final_scores_perc <- students_df[[cols$final]]\n    if (params$fill.test && length(cols$test) > 0) {\n      valid_fill_test_cols <- intersect(cols$test, names(students_df))\n      if(length(valid_fill_test_cols) > 0) students_df <- students_df %>% mutate(across(all_of(valid_fill_test_cols), ~ pmax(., final_scores_perc, na.rm = TRUE)))\n    }\n    if (params$fill.hw && length(cols$hw) > 0) {\n      valid_fill_hw_cols <- intersect(cols$hw, names(students_df))\n      if(length(valid_fill_hw_cols) > 0) students_df <- students_df %>% mutate(across(all_of(valid_fill_hw_cols), ~ pmax(., final_scores_perc, na.rm = TRUE)))\n    }\n  } else {\n    stop(\"Internal Error: Final column identified but not found in students_df for fill operation.\")\n  }\n  \n  # --- Calculate Weighted Component Scores ---\n  valid_hw_cols <- cols$hw # Already filtered\n  valid_test_cols <- cols$test # Already filtered\n  n_hw_total <- length(valid_hw_cols)\n  n_test_total <- length(valid_test_cols)\n  n_hw_effective <- max(0, min(n_hw_total, n_hw_total - params$n.omitted.hw))\n  n_test_effective <- max(0, min(n_test_total, n_test_total - params$n.omitted.test))\n  \n  students_df <- students_df %>% mutate(\n    Nhw = if (n_hw_total > 0) rowSums(select(., all_of(valid_hw_cols)) != 0, na.rm = TRUE) else 0,\n    Ntest = if (n_test_total > 0) rowSums(select(., all_of(valid_test_cols)) != 0, na.rm = TRUE) else 0\n  )\n  \n  students_df$HW_Avg <- if (n_hw_effective > 0 && n_hw_total > 0) { apply(students_df[, valid_hw_cols, drop = FALSE], 1, maxmean, n = n_hw_effective) } else { 0 }\n  students_df$Test_Avg <- if (n_test_effective > 0 && n_test_total > 0) { apply(students_df[, valid_test_cols, drop = FALSE], 1, maxmean, n = n_test_effective) } else { 0 }\n  \n  students_df <- students_df %>% mutate(\n    HW = coalesce(HW_Avg * params$weights[\"HW\"], 0),\n    Test = coalesce(Test_Avg * params$weights[\"Test\"], 0),\n    Final_Score = if (cols$final %in% names(.)) .[[cols$final]] else NA_real_,\n    Final_Weighted = coalesce(Final_Score * params$weights[\"Final\"], 0)\n  )\n  \n  # --- Calculate Overall Scores ---\n  students_df <- students_df %>% mutate(\n    Term = HW + Test,\n    calculated = Term + Final_Weighted\n  )\n  \n  # Initialize maxFinal based on 'calculated'\n  students_df$maxFinal <- students_df$calculated\n  \n  # Apply the max logic\n  if(params$final.only == TRUE && \"Final_Score\" %in% names(students_df)) {\n    if(is.numeric(students_df$calculated) && is.numeric(students_df$Final_Score)) {\n      if(length(students_df$calculated) == length(students_df$Final_Score)) {\n        idx_valid_final <- !is.na(students_df$Final_Score)\n        if(any(idx_valid_final)) {\n          students_df$maxFinal[idx_valid_final] <- pmax(\n            students_df$calculated[idx_valid_final],\n            students_df$Final_Score[idx_valid_final],\n            na.rm = TRUE\n          )\n        }\n      } else {\n        warning(\"Length mismatch between 'calculated' and 'Final_Score'. Using 'calculated' for 'maxFinal'.\")\n      }\n    } else {\n      warning(\"'Final_Score' or 'calculated' column is not numeric. Using 'calculated' for 'maxFinal'.\")\n    }\n  }\n  \n  # === Apply Adjustments ===\n  students_df$adjusted <- students_df$maxFinal; max_score_cap <- 99; adjustment_rules <- params$adjustment_rules\n  if (length(adjustment_rules) > 0 && \"maxFinal\" %in% names(students_df)) {\n    sorted_rules <- adjustment_rules[order(sapply(adjustment_rules, `[[`, \"lower\"), decreasing = TRUE)]; adjusted_indices <- c()\n    for (rule in sorted_rules) {\n      lower_b <- rule$lower; upper_b <- rule$upper; mark_add <- rule$added\n      if (!\"adjusted\" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal\n      \n      students_sel_idx <- which( !is.na(students_df$maxFinal) & students_df$maxFinal >= lower_b & students_df$maxFinal < upper_b & !(seq_len(nrow(students_df)) %in% adjusted_indices) )\n      if (length(students_sel_idx) > 0) {\n        adjusted_values <- students_df$maxFinal[students_sel_idx] + mark_add\n        students_df$adjusted[students_sel_idx] <- pmin(adjusted_values, upper_b ); adjusted_indices <- c(adjusted_indices, students_sel_idx)\n      }\n    }\n    students_df <- students_df %>% mutate(adjusted = pmin(adjusted, max_score_cap))\n  } else {\n    if (!\"adjusted\" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal\n    students_df <- students_df %>% mutate(adjusted = pmin(adjusted, max_score_cap))\n  }\n  \n  # --- Final Rounding ---\n  if (!\"adjusted\" %in% names(students_df)) students_df$adjusted <- students_df$maxFinal\n  students_df <- students_df %>% mutate( submitted = round(adjusted) )\n  \n  # --- Final Output Selection ---\n  final_output_cols <- c( cols$student, cols$id, \"Nhw\", \"HW\", \"Ntest\", \"Test\", \"Final_Score\", \"calculated\", \"maxFinal\", \"adjusted\", \"submitted\" )\n  final_output_cols_exist <- intersect(final_output_cols, names(students_df))\n  processed_marks_final <- students_df %>%\n    select(all_of(final_output_cols_exist)) %>%\n    arrange(if(\"submitted\" %in% final_output_cols_exist && is.numeric(.$submitted)) desc(submitted) else 1)\n  \n  \n  # --- Internal Raw Marks Display Preparation ---\n  cols_orig_for_raw <- identify_columns(df_original)\n  raw_display_cols <- unique(c(cols_orig_for_raw$student, cols_orig_for_raw$id, cols_orig_for_raw$marks))\n  raw_display_cols <- raw_display_cols[!is.na(raw_display_cols)]\n  student_col_raw <- cols_orig_for_raw$student\n  if(is.na(student_col_raw) || !student_col_raw %in% colnames(df_original)){\n    warning(\"Cannot identify student column in original data for raw preview preparation.\")\n    raw_marks_display_internal <- data.frame(Message = \"Error: Could not find student column for raw preview.\")\n  } else {\n    points_possible_row_idx_for_raw <- which(tolower(df_original[[student_col_raw]]) == \"points possible\")\n    raw_display_cols <- intersect(raw_display_cols, colnames(df_original))\n    if(length(points_possible_row_idx_for_raw) == 1 && length(raw_display_cols) > 0) {\n      raw_marks_display_internal <- df_original %>% select(all_of(raw_display_cols))\n      points_possible_row_data_internal <- raw_marks_display_internal[points_possible_row_idx_for_raw, , drop = FALSE]\n      student_rows_internal <- raw_marks_display_internal[-points_possible_row_idx_for_raw, , drop = FALSE]\n      raw_marks_display_internal <- bind_rows(points_possible_row_data_internal, student_rows_internal)\n      colnames(raw_marks_display_internal) <- str_replace(colnames(raw_marks_display_internal), \"\\\\.\\\\.\\\\d+\\\\.?\", \"\")\n    } else {\n      warning(\"Could not prepare the raw marks display section using original data.\")\n      raw_marks_display_internal <- data.frame(Message = \"Could not generate raw preview for calculation results.\")\n      if(!is.null(df_original)) raw_marks_display_internal <- df_original\n    }\n  }\n  \n  # --- Return ---\n  return(list(processed_marks = processed_marks_final,\n              raw_marks_display = raw_marks_display_internal,\n              identified_columns = cols))\n}\n\n\n# --- Define UI (Includes Wider fileInput & Custom Downloads) ---\nui <- fluidPage(\n  tags$head(tags$style(HTML(\"body { font-family: sans-serif; }\n                             .btn-xs { padding: 1px 5px; font-size: 12px; line-height: 1.5; border-radius: 3px; }\n                             .btn-sm { padding: .25rem .5rem; font-size: .875rem; line-height: 1.5; border-radius: .2rem; }\"))),\n  theme = shinytheme(\"spacelab\"),\n  titlePanel(\"Student Mark Calculator\"),\n  \n  sidebarLayout(\n    # Sidebar Panel: Calculation Controls (Unchanged)\n    sidebarPanel(\n      width = 3,\n      h4(\"Calculation Controls\"), tags$hr(),\n      h5(\"Component Weights (%)\"),\n      fluidRow(\n        column(4, numericInput(\"weight_hw\", \"HW %\", value = 30, min = 0, max = 100, step = 1)),\n        column(4, numericInput(\"weight_test\", \"Test %\", value = 20, min = 0, max = 100, step = 1)),\n        column(4, numericInput(\"weight_final\", \"Final %\", value = 50, min = 0, max = 100, step = 1))\n      ),\n      textOutput(\"weight_sum_check\"), tags$hr(),\n      h5(\"Fill / Max Options\"),\n      checkboxInput(\"fill_hw\", \"Fill missing/lower HW w/ Final %\", value = FALSE),\n      checkboxInput(\"fill_test\", \"Fill missing/lower Test w/ Final %\", value = TRUE),\n      checkboxInput(\"final_only\", \"Grade = max(Calculated, Final %)\", value = FALSE), tags$hr(),\n      h5(\"Omit Lowest Scores\"),\n      fluidRow(\n        column(6, numericInput(\"n_omitted_hw\", \"# Omitted HWs\", value = 0, min = 0, step = 1)),\n        column(6, numericInput(\"n_omitted_test\", \"# Omitted Tests\", value = 0, min = 0, step = 1))\n      ), tags$hr(),\n      div(style=\"display: flex; align-items: center; justify-content: space-between;\",\n          h5(\"Grade Adjustment Rules\", style=\"margin-bottom: 0;\"),\n          tags$a(id = \"adj_rules_help\", href = \"#\", onclick=\"return false;\", icon(\"question-circle\", class = \"fa-lg\"), style = \"margin-left: 5px; color: #007bff; cursor: pointer; text-decoration: none;\")\n      ),\n      bsPopover(id = \"adj_rules_help\", title = \"Adjustment Rule Format\",\n                content = HTML(paste(\"Enter rules using the format: <code>[Lower, Upper]: Added<\/code>\",\n                                     \"Rules must be separated by semicolons (<code>;<\/code>).\",\n                                     \"<em>Example:<\/em><br/><code>[0, 50]: 2; [50, 70]: 4; [70, 100]: 0<\/code>\",\n                                     \"A student's score falling within <code>[Lower, Upper)<\/code> gets points added.\",\n                                     \"Adjusted score capped at rule's <code>Upper<\/code> bound OR 99 overall (whichever is lower).\",\n                                     sep = \"<br/><br/>\")),\n                placement = \"right\", trigger = \"click\", options = list(container = \"body\")\n      ),\n      textInput(\"adjustment_rules_text\", label = NULL, placeholder = \"[L1, U1]: A1; [L2, U2]: A2; ...\", value = \"[0,50]: 0; [50, 70]: 0; [70, 100]: 0\"), # User default value\n      tags$hr(),\n      # --- Author Information Added Here ---\n      tags$div(style = \"margin-top: 20px; font-size: 0.9em; color: grey; text-align: center;\",\n               HTML('Author: Longhai Li<br>(<a href=\"https://longhaisk.github.io\" target=\"_blank\">https://longhaisk.github.io<\/a>)')\n      )\n    ), # End sidebarPanel\n    \n    # Main Panel: Tabs\n    mainPanel(\n      width = 9,\n      tabsetPanel(\n        id = \"mainTabs\",\n        # Tab 1: Uploading Marks (Wider fileInput)\n        tabPanel(\"Uploading Marks\",\n                 h4(\"Upload Mark File\"),\n                 # MODIFIED: Added width = '100%'\n                 fileInput(\"markFile\", \"Choose CSV File\",\n                           accept = c(\".csv\", \"text/csv\"),\n                           width = '100%'\n                 ),\n                 verbatimTextOutput(\"fileReadStatusOutput\", placeholder = TRUE),\n                 h4(\"Input Data Preview (Identified & Validated Columns)\"),\n                 DTOutput(\"rawMarksTable\"),\n                 hr(),\n                 h4(\"Columns Identified by Category\"),\n                 verbatimTextOutput(\"identifiedColumnsText\")\n        ), # End Uploading Marks tabPanel\n        \n        # Tab 2: Calculating Grades (Conditional display & Custom Downloads)\n        tabPanel(\"Calculating Grades\",\n                 h4(\"Calculate & View Processed Marks\"),\n                 actionButton(\"calculate\", \"Calculate Grades\", icon = icon(\"calculator\"), class = \"btn-primary\", style=\"margin-bottom: 5px;\"),\n                 tags$p(em(\"Configure Controling Parameters in the Sidebar and Click Calculate.\"), style=\"margin-top: 10px; margin-bottom: 15px; color: #555; font-size:0.9em;\"),\n                 hr(), # Separator before display options\n                 \n                 # Display options and Reorder button\n                 fluidRow(\n                   column(width = 4, radioButtons(\"results_view_type\", \"Select Display:\", choices = c(\"Interactive Table\" = \"Table\", \"Spreadsheet View\" = \"Spreadsheet\"), selected = \"Table\", inline = TRUE)),\n                   column(width = 2, div(style=\"margin-top: 5px;\", actionButton(inputId = \"showReorderUI\", label = \"Reorder Columns\", icon = icon(\"sort\"))))\n                 ),\n                 tags$hr(style=\"margin-top:0px;\"),\n                 \n                 # Render Table/Spreadsheet UI directly via conditionalPanel\n                 conditionalPanel(\n                   condition = \"input.results_view_type == 'Table'\",\n                   DTOutput(\"processedMarksTable\")\n                 ),\n                 conditionalPanel(\n                   condition = \"input.results_view_type == 'Spreadsheet'\",\n                   rHandsontableOutput(\"processedMarksSpreadsheet\")\n                 ),\n                 \n                 # Custom Download Buttons\n                 hr(),\n                 h4(\"Export Processed Marks with Notes\"),\n                 fluidRow(\n                   column(width = 3,\n                          downloadButton(\"downloadCsvWithNotes\", \"Download CSV w/ Notes\", class=\"btn-sm\")\n                   ),\n                   column(width = 3,\n                          downloadButton(\"downloadXlsxWithNotes\", \"Download Excel w/ Notes\", class=\"btn-sm\")\n                   )\n                 ),\n                 \n                 # Verification Info\n                 hr(),\n                 h4(\"Additional Rows for Verification\"),\n                 tags$p(em(\"Shows calculated results for the 'Points Possible' row and any rows excluded from the main table above due to non-numeric IDs.\"), style=\"color: #555; font-size:0.9em;\"),\n                 uiOutput(\"specialRowsInfoUI\"),\n                 \n                 # In-App Calculation Notes\n                 hr(),\n                 h4(\"Calculation Notes\"),\n                 uiOutput(\"processedMarksNotes\"),\n                 hr()\n        ), # End Calculating Grades tabPanel\n        \n        # Tab 3: Statistics & Plots (Unchanged)\n        tabPanel(\"Statistics & Plots\",\n                 h4(\"Summary Statistics for Submitted Marks \"),\n                 verbatimTextOutput(\"summaryStats\"),\n                 hr(),\n                 h4(\"Distribution Plots \"),\n                 plotOutput(\"distPlots\", height = \"450px\")\n        ), # End Stats tabPanel\n        \n        # Tab 4: Help (Updated instructions)\n        tabPanel(\"Help\",\n                 h3(\"How to Use This Calculator\"),\n                 tags$ol(\n                   tags$li(tags$strong(\"Upload CSV:\"), \" Go to the 'Uploading Marks' tab and select your gradebook export. It needs a 'Student' column and a 'Points Possible' row containing positive numeric values for columns to be included.\"),\n                   tags$li(tags$strong(\"Preview Raw Data:\"), \" On the 'Uploading Marks' tab, a preview appears showing only identified student, ID, and mark columns that have numeric 'Points Possible' values. Below the preview, a summary lists the columns identified for each category (HW, Test, Final).\"),\n                   tags$li(tags$strong(\"Set Parameters:\"), \" Use the 'Calculation Controls' sidebar for Weights (as %), Fill/Omit options, and Adjustment Rules. Click the \", icon(\"question-circle\"), \" icon for help on adjustment rules.\"),\n                   tags$li(tags$strong(\"Set Adjustments:\"), \" Use the 'Grade Adjustment Rules' text box in the sidebar.\"),\n                   tags$li(tags$strong(\"Calculate:\"), \" Go to 'Calculating Grades' tab, click the 'Calculate Grades' button.\"),\n                   tags$li(tags$strong(\"Define Column Order (Optional):\"), \" On the 'Calculating Grades' tab, click the 'Reorder Display Columns' button located beside the 'Select Display' options. A pop-up window will appear where you can drag and drop column names to set your preferred display order for the results table/spreadsheet.\"),\n                   tags$li(tags$strong(\"Review Results:\"), \" Check the main results table (respecting your chosen column order), the 'Calculation Notes' (in-app version), the 'Verification Information' section (for calculated 'Points Possible' row and non-numeric ID rows), and the 'Statistics & Plots' tab (based on numeric ID students).\"),\n                   tags$li(tags$strong(\"Export Results w/ Notes:\"), \" On the 'Calculating Grades' tab, use the 'Download CSV w/ Notes' or 'Download Excel w/ Notes' buttons below the results table to export the data along with the calculation parameters used. The filename will be based on your uploaded file.\")\n                 ),\n                 h4(\"Column Naming Conventions\"),\n                 p(\"Tool identifies columns by name prefixes AND requires a numeric 'Points Possible' value:\"),\n                 tags$ul(tags$li(\"HW/Assign: 'HW'/'A'\"), tags$li(\"Tests: 'Test'/'Midterm'\"), tags$li(\"Final: 'Final'\"),\n                         tags$li(\"Student Name: 'Student'\"), tags$li(\"ID: Prefers 'SIS User ID', finds 'ID'/'Student ID'\")),\n                 h4(\"Important Notes\"),\n                 tags$ul(\n                   tags$li(\"Columns identified as marks (HW*, Test*, Final) MUST have a positive numeric value in the 'Points Possible' row to be included in calculations.\"),\n                   tags$li(\"Missing student scores are treated as 0 (unless 'Fill' active).\"),\n                   tags$li(\"'Spreadsheet View' is read-only.\"),\n                   tags$li(\"Ensure weights sum to 100%.\"),\n                   tags$li(\"The main results table/spreadsheet and the statistics/plots only include students whose identified ID is numeric. Calculated results for the 'Points Possible' row and rows with non-numeric IDs (e.g., 'Test Student') are shown separately in the 'Verification Information' section on the 'Calculating Grades' tab.\"),\n                   tags$li(\"Exported files (CSV/Excel) via the download buttons contain the calculation notes/parameters used and are named based on the input file.\")\n                 )\n        ) # End Help tabPanel\n      ) # End tabsetPanel\n    ) # End mainPanel\n  ) # End sidebarLayout\n) # End fluidPage\n\n\n# --- Define Server Logic (Includes Custom Downloads with Notes & Filenames) ---\n# --- Load Libraries (Assumed to be loaded from the Rmd setup chunk) ---\n# library(shiny)\n# library(tidyverse) # Includes dplyr, stringr, readr, ggplot2, tidyr\n# library(DT)\n# library(rhandsontable)\n# library(shinyjs)\n# library(shinyWidgets)\n# library(ggplot2)\n# library(scales)\n# library(shinythemes)\n# library(shinyBS)\n# library(lubridate)\n# library(knitr)\n# library(patchwork)\n# library(sortable)\n# library(writexl)\n# library(tools)\n\n# --- Helper Functions (Assumed to be defined from the Rmd setup chunk) ---\n# maxmean <- function(...) { ... }\n# identify_columns <- function(...) { ... }\n# parse_adjustment_rules <- function(...) { ... }\n# generate_notes_text <- function(...) { ... }\n# calculate_grades <- function(...) { ... }\n\n\nserver <- function(input, output, session) {\n  \n  rv <- reactiveValues(\n    raw_data = NULL,\n    raw_data_preview = NULL,\n    identified_cols_list = NULL,\n    calculated_results = NULL,\n    calculation_params = NULL,\n    file_status_msg = \"Upload a CSV file on the 'Uploading Marks' tab.\",\n    calculation_error = NULL,\n    current_column_order = NULL\n  )\n  \n  # --- File Input Handling (Revised Filtering Logic) ---\n  observeEvent(input$markFile, {\n    req(input$markFile); infile <- input$markFile\n    \n    # Reset reactive values on new file upload\n    rv$file_status_msg <- \"Reading file...\"; rv$raw_data <- NULL; rv$raw_data_preview <- NULL; rv$calculated_results <- NULL\n    rv$calculation_params <- NULL; rv$calculation_error <- NULL; rv$identified_cols_list <- NULL\n    rv$current_column_order <- NULL\n    \n    tryCatch({\n      # Step 1: Read the raw CSV data\n      df_read <- read_csv(infile$datapath, show_col_types = FALSE, na = c(\"\", \"NA\", \"#N/A\"), guess_max = 10000, trim_ws = TRUE)\n      if (nrow(df_read) < 2) stop(\"CSV file must contain at least 2 rows (including 'Points Possible').\")\n      raw_data_temp <- as.data.frame(df_read)\n      original_row_count <- nrow(raw_data_temp)\n      rv$file_status_msg <- \"File read. Identifying columns...\"\n      \n      # Step 2: Initial column identification on the *original* data\n      # This is needed to know which columns to check for filtering and to find the 'Points Possible' row\n      identified_cols_initial <- identify_columns(raw_data_temp)\n      student_col_name <- identified_cols_initial$student\n      if (is.na(student_col_name) || !student_col_name %in% colnames(raw_data_temp)) {\n        stop(\"Cannot identify the 'Student' column in the uploaded file.\")\n      }\n      mark_cols_to_check <- identified_cols_initial$marks # Use all identified mark columns for filtering check\n      rv$file_status_msg <- \"Columns identified. Filtering rows...\"\n      \n      # Step 3: Filter rows based on numeric content in identified mark columns\n      filtered_data <- raw_data_temp\n      rows_removed <- 0\n      \n      # Find the 'Points Possible' row index *before* filtering\n      points_possible_row_idx <- which(tolower(raw_data_temp[[student_col_name]]) == \"points possible\")\n      if (length(points_possible_row_idx) != 1) {\n        stop(\"Could not find exactly one 'Points Possible' row in the '\", student_col_name, \"' column.\")\n      }\n      \n      if (length(mark_cols_to_check) > 0) {\n        # Ensure the mark columns actually exist in the dataframe\n        valid_filter_cols <- intersect(mark_cols_to_check, colnames(raw_data_temp))\n        \n        if (length(valid_filter_cols) > 0) {\n          # Keep the 'Points Possible' row AND rows where AT LEAST ONE mark column is numeric\n          filtered_data <- raw_data_temp %>%\n            dplyr::filter(\n              # Condition 1: Keep the Points Possible row explicitly\n              dplyr::row_number() == points_possible_row_idx |\n                # Condition 2: Keep rows where *any* of the identified mark columns are numeric\n                dplyr::if_any(\n                  dplyr::all_of(valid_filter_cols),\n                  ~ !is.na(suppressWarnings(as.numeric(.))) # Check if value can be numeric\n                )\n            )\n          filtered_row_count <- nrow(filtered_data)\n          rows_removed <- original_row_count - filtered_row_count\n          rv$file_status_msg <- paste(\"File read. Identified columns. Filtered\", rows_removed, \"rows lacking numeric data in all mark columns.\")\n        } else {\n          warning(\"Filtering skipped: Identified mark columns not found in the data frame headers after initial read.\")\n          rv$file_status_msg <- \"File read. Identified columns. Filtering skipped: No valid mark columns found.\"\n        }\n      } else {\n        warning(\"Filtering skipped: No mark columns (HW, Test, Final) were identified by name and valid PP row value.\")\n        rv$file_status_msg <- \"File read. Identified columns. Filtering skipped: No mark columns identified.\"\n      }\n      \n      # Step 4: Check if enough rows remain after filtering\n      if (nrow(filtered_data) < 2) {\n        stop(paste(\"After filtering, less than 2 rows remain (only\", nrow(filtered_data), \"rows). Check if 'Points Possible' or essential student rows were unexpectedly removed. Original rows:\", original_row_count))\n      }\n      \n      # Step 5: Store the FILTERED data\n      rv$raw_data <- filtered_data\n      rv$file_status_msg <- paste(rv$file_status_msg, \"Identifying final columns for calculation...\")\n      \n      # Step 6: Re-identify columns based on the FILTERED data\n      # This ensures the list used for calculations is based on the data that will actually be processed\n      # It also implicitly re-validates the 'Points Possible' row values for the remaining columns\n      rv$identified_cols_list <- identify_columns(rv$raw_data)\n      rv$file_status_msg <- paste(rv$file_status_msg, \"Generating preview...\")\n      \n      \n      # Step 7: Generate preview using the FILTERED data and FINAL identified columns\n      tryCatch({\n        cols_preview <- rv$identified_cols_list # Use the final list based on filtered data\n        # Re-validate student column presence after filtering and re-identification\n        if (is.na(cols_preview$student) || !(cols_preview$student %in% colnames(rv$raw_data))) {\n          stop(\"Cannot generate preview: Student column ('\", cols_preview$student ,\"') not found after filtering.\")\n        }\n        \n        # Define columns for the preview table (Student, ID, and FINAL identified Mark columns)\n        valid_raw_display_cols <- unique(c(cols_preview$student, cols_preview$id, cols_preview$marks))\n        valid_raw_display_cols <- valid_raw_display_cols[!is.na(valid_raw_display_cols)] # Remove NA if ID wasn't found\n        valid_raw_display_cols <- intersect(valid_raw_display_cols, colnames(rv$raw_data)) # Ensure they exist in filtered data\n        \n        if (length(valid_raw_display_cols) > 0) {\n          # Find 'Points Possible' row index *in the filtered data*\n          points_possible_row_idx_preview <- which(tolower(rv$raw_data[[cols_preview$student]]) == \"points possible\")\n          if(length(points_possible_row_idx_preview) != 1) {\n            # This should theoretically not happen if step 4 passed, but check anyway\n            stop(\"Could not locate exactly one 'Points Possible' row in the filtered data for preview structuring.\")\n          }\n          \n          # Select columns and reorder rows for preview\n          preview_df <- rv$raw_data %>% select(all_of(valid_raw_display_cols))\n          points_possible_row_data_preview <- preview_df[points_possible_row_idx_preview, , drop = FALSE]\n          student_rows_preview <- preview_df[-points_possible_row_idx_preview, , drop = FALSE]\n          temp_preview <- bind_rows(points_possible_row_data_preview, student_rows_preview)\n          \n          # Clean up potential duplicate column names (e.g., from read_csv)\n          colnames(temp_preview) <- str_replace(colnames(temp_preview), \"\\\\.\\\\.\\\\.\\\\d+$\", \"\") # More specific regex for ...# suffix\n          colnames(temp_preview) <- make.unique(colnames(temp_preview)) # Ensure uniqueness if needed after cleaning\n          \n          rv$raw_data_preview <- temp_preview\n          rv$file_status_msg <- paste0(\"File read successfully. Filtered \", rows_removed, \" rows. Preview below shows identified columns from remaining data.\")\n        } else {\n          stop(\"No valid columns (Student, ID, Marks) remain for preview after filtering and final identification.\")\n        }\n      }, error = function(e_preview) {\n        rv$raw_data_preview <- data.frame(Message=paste(\"Preview Error:\", e_preview$message))\n        rv$file_status_msg <- paste(rv$file_status_msg, \"Preview generation failed:\", e_preview$message)\n        warning(paste(\"Could not generate structured raw preview:\", e_preview$message))\n      })\n      \n    }, error = function(e_main) {\n      # Catch errors from reading, initial identification, filtering, or final identification\n      error_message <- paste(\"Error during file processing:\", e_main$message)\n      rv$file_status_msg <- error_message\n      showNotification(error_message, type = \"error\", duration = 10)\n      # Reset all relevant reactive values on error\n      rv$raw_data <- NULL; rv$raw_data_preview <- NULL; rv$identified_cols_list <- NULL\n      rv$calculated_results <- NULL; rv$calculation_params <- NULL; rv$calculation_error <- NULL\n      rv$current_column_order <- NULL\n    })\n  }) # End observeEvent input$markFile\n  \n  \n  # --- Output: File Read Status (Unchanged) ---\n  output$fileReadStatusOutput <- renderText({ rv$file_status_msg })\n  \n  # --- Output: Identified Columns Text (Unchanged) ---\n  # This now correctly reflects the columns identified *after* filtering\n  output$identifiedColumnsText <- renderPrint({\n    req(rv$identified_cols_list)\n    cols <- rv$identified_cols_list\n    cat(\"--- Columns Identified (Post-Filtering) for Calculation ---\\n\")\n    cat(\"Student Column:\", ifelse(is.na(cols$student), \"Not Found\", cols$student), \"\\n\")\n    cat(\"ID Column:\", ifelse(is.na(cols$id), \"Not Found\", cols$id), \"\\n\")\n    cat(\"Final Exam Column:\", ifelse(is.na(cols$final) || !nzchar(cols$final), \"Not Found / Invalid PP\", cols$final), \"\\n\")\n    cat(\"Homework Columns (\", length(cols$hw), \"): \", if(length(cols$hw)>0) paste(cols$hw, collapse=\", \") else \"None\", \"\\n\", sep=\"\")\n    cat(\"Test Columns (\", length(cols$test), \"): \", if(length(cols$test)>0) paste(cols$test, collapse=\", \") else \"None\", \"\\n\", sep=\"\")\n    cat(\"----------------------------------------------------------\\n\")\n  })\n  \n  # --- Parameter Validation: Weight Sum Check (Unchanged) ---\n  output$weight_sum_check <- renderText({\n    weights_perc <- c(input$weight_hw, input$weight_test, input$weight_final)\n    if(any(is.na(weights_perc))) return(\"Enter numeric weights.\")\n    ws_perc <- sum(weights_perc)\n    if (abs(ws_perc - 100.0) > 1e-6) {\n      paste(\"Warning: Weights sum to\", round(ws_perc, 2), \"% (should be 100%)\")\n    } else {\n      \"Weights sum to 100%\"\n    }\n  })\n  \n  # --- Adjustment Rules Popover (Unchanged - Requires shinyBS) ---\n  # Make sure shinyBS::addPopover is called appropriately if needed,\n  # usually outside the main server function or within an observe block\n  # that has access to the session object. If this code is directly inside\n  # the server function body, it might need adjustment.\n  # Example placeholder:\n  observe({\n    addPopover(session=session, id = \"adj_rules_help\", title = \"Adjustment Rule Format\",\n               content = HTML(paste(\"Enter rules using the format: <code>[Lower, Upper]: Added<\/code>\",\n                                    \"Rules must be separated by semicolons (<code>;<\/code>).\",\n                                    \"<em>Example:<\/em><br/><code>[0, 50]: 2; [50, 70]: 4; [70, 100]: 0<\/code>\",\n                                    \"A student's score falling within <code>[Lower, Upper)<\/code> gets points added.\",\n                                    \"Adjusted score capped at rule's <code>Upper<\/code> bound OR 99 overall (whichever is lower).\",\n                                    sep = \"<br/><br/>\")),\n               placement = \"right\", trigger = \"click\", options = list(container = \"body\")\n    )\n  })\n  \n  \n  # --- Calculation Trigger (Unchanged) ---\n  observeEvent(input$calculate, {\n    # Requires rv$raw_data (now filtered) and rv$identified_cols_list (now based on filtered data)\n    req(rv$raw_data, rv$identified_cols_list, cancelOutput = TRUE)\n    \n    if (is.null(rv$raw_data)) {\n      showNotification(\"Cannot calculate: Filtered data is missing. Please re-upload.\", type = \"warning\"); return()\n    }\n    if (is.null(rv$identified_cols_list)) {\n      showNotification(\"Cannot calculate: Column identification failed after filtering. Please check file and re-upload.\", type = \"warning\", duration=10); return()\n    }\n    \n    # --- Parameter validation (weights, rules, omissions) ---\n    weights_perc <- c(input$weight_hw, input$weight_test, input$weight_final)\n    if(any(is.na(weights_perc))) { showNotification(\"Calculation aborted: One or more weights are not numeric.\", type=\"error\"); return() }\n    if (abs(sum(weights_perc) - 100.0) > 1e-6) {\n      showNotification(paste(\"Calculation aborted: Weights must sum to 100% (currently\", round(sum(weights_perc),2), \"%)\"), type=\"error\"); return()\n    }\n    weights_decimal <- c(HW = input$weight_hw / 100, Test = input$weight_test / 100, Final = input$weight_final / 100)\n    \n    adjustment_rules_list <- list(); rules_input_string <- input$adjustment_rules_text; validation_passed <- TRUE\n    tryCatch({\n      adjustment_rules_list <- parse_adjustment_rules(rules_input_string)\n    }, error = function(e) {\n      showNotification(paste(\"Error parsing adjustment rules:\", e$message), type = \"error\", duration = 10); validation_passed <<- FALSE\n    })\n    if (!validation_passed) return()\n    \n    n_omit_hw <- floor(input$n_omitted_hw); n_omit_test <- floor(input$n_omitted_test)\n    if(is.na(n_omit_hw) || n_omit_hw < 0 || is.na(n_omit_test) || n_omit_test < 0) {\n      showNotification(\"Calculation aborted: Number of omitted scores must be a non-negative integer.\", type=\"error\"); return()\n    }\n    \n    # --- Prepare parameters and run calculation ---\n    current_params <- list(\n      weights = weights_decimal,\n      fill.hw = input$fill_hw, fill.test = input$fill_test, final.only = input$final_only,\n      n.omitted.hw = n_omit_hw, n.omitted.test = n_omit_test,\n      adjustment_rules_string = rules_input_string, adjustment_rules = adjustment_rules_list\n    )\n    rv$calculation_params <- current_params\n    rv$calculation_error <- NULL # Clear previous errors\n    \n    tryCatch({\n      showNotification(\"Calculating grades...\", type = \"message\", duration = 2, id=\"calc_msg\")\n      # Use the filtered rv$raw_data for calculations\n      results <- calculate_grades(rv$raw_data, current_params)\n      rv$calculated_results <- results\n      \n      # Initialize/Reset column order based on calculated results\n      if (!is.null(results$processed_marks) && ncol(results$processed_marks) > 0) {\n        initial_cols <- setdiff(colnames(results$processed_marks), \"adjusted\") # Exclude intermediate column\n        rv$current_column_order <- initial_cols\n      } else {\n        rv$current_column_order <- NULL # Handle case with no results or empty results\n      }\n      \n      rv$calculation_error <- NULL # Calculation succeeded\n      removeNotification(\"calc_msg\", session=session)\n      updateTabsetPanel(session, inputId = \"mainTabs\", selected = \"Calculating Grades\")\n      showNotification(\"Calculations complete!\", type = \"message\", duration = 5)\n      \n    }, error = function(e) {\n      err_msg <- paste(\"Error during calculation:\", e$message)\n      rv$calculation_error <- err_msg\n      rv$calculated_results <- NULL # Clear results on error\n      rv$current_column_order <- NULL # Reset column order on error\n      removeNotification(\"calc_msg\", session=session)\n      showNotification(err_msg, type = \"error\", duration = 10)\n      # Optional: Print detailed error to console for debugging\n      cat(\"\\n--- Error Caught in Calculation ---\\n\"); print(e); cat(\"--- End Error Details ---\\n\\n\")\n    })\n  }) # End observeEvent input$calculate\n  \n  \n  # --- Show Modal Dialog for Column Reordering (Unchanged) ---\n  observeEvent(input$showReorderUI, {\n    req(rv$calculated_results$processed_marks)\n    current_order <- rv$current_column_order\n    # If order is NULL (e.g., first calculation), initialize it\n    if (is.null(current_order)) {\n      initial_cols <- setdiff(colnames(rv$calculated_results$processed_marks), \"adjusted\")\n      if(length(initial_cols) == 0){\n        showNotification(\"Cannot determine columns to reorder.\", type=\"warning\")\n        return()\n      }\n      current_order <- initial_cols\n      rv$current_column_order <- current_order # Store the initial order\n    }\n    \n    showModal(modalDialog(\n      title = \"Reorder Table Columns\",\n      p(\"Drag and drop column names into the desired order.\"),\n      rank_list(\n        text = NULL,\n        labels = current_order, # Use the potentially initialized order\n        input_id = \"columnOrderModal\",\n        options = sortable_options()\n      ),\n      footer = tagList(\n        modalButton(\"Cancel\"),\n        actionButton(\"applyColOrder\", \"Apply Order\", class = \"btn-primary\")\n      ),\n      size = \"m\",\n      easyClose = TRUE\n    ))\n  })\n  \n  # --- Observer to apply the order from the modal (Unchanged) ---\n  observeEvent(input$applyColOrder, {\n    req(input$columnOrderModal)\n    rv$current_column_order <- input$columnOrderModal # Update stored order\n    removeModal()\n    showNotification(\"Column order updated.\", type = \"message\", duration = 3)\n  })\n  \n  \n  # --- Reactive Expression for Processed Data to Display (Unchanged) ---\n  # This reactive now depends on rv$calculated_results (from filtered data)\n  # and rv$current_column_order\n  display_data <- reactive({\n    req(rv$calculated_results$processed_marks, rv$calculated_results$identified_columns)\n    req(rv$current_column_order) # Ensure an order is set before proceeding\n    \n    processed_df <- rv$calculated_results$processed_marks\n    cols_info <- rv$calculated_results$identified_columns\n    id_col_name <- cols_info$id\n    student_col_name <- cols_info$student\n    \n    validate(need(nrow(processed_df) >= 0, \"Processed data frame is NULL or invalid.\"))\n    validate(need(!is.na(student_col_name) && student_col_name %in% names(processed_df), \"Student column not found in processed results.\"))\n    \n    # Filter for numeric IDs (using the identified ID column name)\n    numeric_id_rows_df <- processed_df\n    if (!is.na(id_col_name) && id_col_name %in% names(processed_df) && id_col_name != \"Student.ID.Placeholder\") {\n      id_values <- processed_df[[id_col_name]]\n      # Robust check for numeric-like IDs (handles actual numbers and numeric strings)\n      is_numeric_id <- !is.na(suppressWarnings(as.numeric(as.character(id_values)))) &\n        !is.na(id_values) & # Exclude explicit NAs\n        str_trim(as.character(id_values)) != \"\" # Exclude empty/whitespace strings\n      numeric_id_rows_df <- processed_df[is_numeric_id, , drop = FALSE]\n    } else {\n      if(!is.na(id_col_name) && id_col_name != \"Student.ID.Placeholder\") {\n        warning(paste(\"Cannot filter results by ID: ID column ('\", id_col_name, \"') not found or invalid. Proceeding without ID filter.\", sep=\"\"))\n      }\n      # If ID column is NA or placeholder, keep all rows (no ID filtering)\n    }\n    \n    # Filter out Points Possible row (using the identified Student column name)\n    final_filtered_df_unord <- numeric_id_rows_df %>%\n      filter(tolower(.data[[student_col_name]]) != \"points possible\") %>%\n      select(-any_of(\"adjusted\")) # Remove intermediate 'adjusted' column before display\n    \n    validate(need(nrow(final_filtered_df_unord) > 0, \"No student data remaining after filtering for numeric IDs and 'Points Possible' row.\"))\n    \n    # Apply column reordering based on rv$current_column_order\n    desired_order <- rv$current_column_order\n    current_cols <- colnames(final_filtered_df_unord)\n    valid_order <- intersect(desired_order, current_cols) # Only use columns that exist\n    \n    # Check if the stored order is still valid/complete for the current data\n    if (length(valid_order) == 0 || length(valid_order) != length(current_cols)) {\n      warning(\"Stored column order was invalid or incomplete compared to available columns. Using default order of remaining columns.\")\n      # Fallback to the order of columns as they are now\n      final_filtered_df_ord <- final_filtered_df_unord\n      # Optionally, update rv$current_column_order to reflect this fallback\n      # rv$current_column_order <- colnames(final_filtered_df_unord)\n    } else {\n      # Apply the valid stored order\n      final_filtered_df_ord <- final_filtered_df_unord[, valid_order, drop = FALSE]\n    }\n    \n    return(final_filtered_df_ord)\n  })\n  \n  # --- Output for Verification Info (Unchanged) ---\n  # This UI now shows rows excluded by the numeric ID filter or the PP row from the *calculated* results\n  output$specialRowsInfoUI <- renderUI({\n    req(rv$calculated_results$processed_marks, rv$calculated_results$identified_columns)\n    processed_df <- rv$calculated_results$processed_marks # The full calculation result\n    cols_info <- rv$calculated_results$identified_columns\n    id_col_name <- cols_info$id\n    student_col_name <- cols_info$student\n    \n    validate(\n      need(!is.null(processed_df), \"Calculation results not yet available.\"),\n      need(!is.null(cols_info), \"Column info not available.\"),\n      need(!is.na(student_col_name) && student_col_name %in% names(processed_df), \"Student column missing in results.\")\n    )\n    \n    # 1. Get the calculated 'Points Possible' row\n    pp_row_calculated <- processed_df %>%\n      filter(tolower(.data[[student_col_name]]) == \"points possible\")\n    \n    # 2. Get rows with non-numeric IDs (that were excluded from display_data)\n    non_numeric_rows <- data.frame() # Initialize empty\n    if (!is.na(id_col_name) && id_col_name %in% names(processed_df) && id_col_name != \"Student.ID.Placeholder\") {\n      id_values <- processed_df[[id_col_name]]\n      is_numeric_id <- !is.na(suppressWarnings(as.numeric(as.character(id_values)))) &\n        !is.na(id_values) &\n        str_trim(as.character(id_values)) != \"\"\n      # Select rows that are NOT numeric ID AND ALSO NOT the points possible row\n      non_numeric_rows <- processed_df %>%\n        filter(!is_numeric_id & (tolower(.data[[student_col_name]]) != \"points possible\"))\n    }\n    \n    # Combine PP row and non-numeric ID rows\n    special_rows_combined <- bind_rows(pp_row_calculated, non_numeric_rows)\n    \n    # --- Display Logic ---\n    if (nrow(special_rows_combined) > 0) {\n      # Try to get the column order from the main display table\n      main_table_cols <- tryCatch({ colnames(display_data()) }, error = function(e) NULL)\n      output_content <- NULL\n      \n      # Fallback if main table columns aren't available yet or errored\n      if(is.null(main_table_cols) || length(main_table_cols) == 0) {\n        main_table_cols <- rv$current_column_order # Use stored order as fallback\n      }\n      \n      # Second fallback if stored order is also null\n      if(is.null(main_table_cols) || length(main_table_cols) == 0) {\n        # Show very basic columns if no order is known\n        cols_to_show_fallback <- intersect(c(student_col_name, id_col_name, \"calculated\", \"submitted\"), names(special_rows_combined))\n        cols_to_show_fallback <- cols_to_show_fallback[!is.na(cols_to_show_fallback)] # Remove NAs (e.g., if id_col_name is NA)\n        \n        if(length(cols_to_show_fallback) > 0) {\n          df_to_show <- special_rows_combined[, cols_to_show_fallback, drop=FALSE]\n          # Simple print output for fallback\n          output_text <- paste(c(\"Could not determine main table columns. Showing basic info:\",\n                                 capture.output(print(df_to_show, row.names = FALSE))), collapse = \"\\n\")\n          output_content <- tags$pre(output_text)\n        } else {\n          output_content <- tags$pre(\"(No relevant basic columns found for special rows)\")\n        }\n      } else {\n        # Use the determined column order (from display_data or fallback)\n        cols_to_show_actual <- intersect(main_table_cols, names(special_rows_combined))\n        cols_to_show_actual <- cols_to_show_actual[!is.na(cols_to_show_actual)] # Ensure valid columns\n        \n        if(length(cols_to_show_actual) > 0){\n          df_to_show <- special_rows_combined %>% select(all_of(cols_to_show_actual))\n          \n          # Apply formatting similar to the main table for consistency\n          df_to_show_formatted <- df_to_show %>%\n            mutate(across(where(is.numeric) & matches(\"^(HW|Test|Final_Score|calculated|maxFinal)$\"), ~ sprintf(\"%.2f\", round(., 2))),\n                   across(where(is.numeric) & matches(\"^(submitted|Nhw|Ntest)$\"), ~ sprintf(\"%.0f\", round(., 0)))) %>%\n            mutate(across(everything(), ~ ifelse(is.na(.), \"\", as.character(.)))) # Convert all to char for kable\n          \n          # Use kable for better formatting\n          output_text <- paste(capture.output(\n            knitr::kable(df_to_show_formatted, format=\"simple\", row.names = FALSE, align = 'l') # Left align for readability\n          ), collapse = \"\\n\")\n          output_content <- tags$pre(tags$code(output_text)) # Use code tag for monospace font\n        } else {\n          output_content <- tags$pre(\"(Could not determine relevant columns to display based on main table).\")\n        }\n      }\n      output_content # Return the generated UI element\n    } else {\n      tags$pre(\"None (No 'Points Possible' row or non-numeric ID rows found in calculated results to display here).\")\n    }\n  })\n  \n  \n  # --- Render Raw Marks Preview Table (DT - Unchanged) ---\n  # Displays rv$raw_data_preview which is generated *after* filtering\n  output$rawMarksTable <- renderDT({\n    validate( need(!is.null(rv$raw_data_preview), \"Upload a valid CSV file to see the preview.\") )\n    # Check if the preview is actually an error message\n    if (ncol(rv$raw_data_preview) == 1 && colnames(rv$raw_data_preview)[1] == \"Message\") {\n      validate(need(FALSE, rv$raw_data_preview$Message[1])) # Display the error message\n    }\n    datatable( rv$raw_data_preview, rownames = FALSE, extensions = 'Buttons',\n               options = list( pageLength = 10, scrollX = TRUE, scrollY = \"400px\", searching = TRUE, paging = TRUE,\n                               dom = 'Bfrtip', # Include B for Buttons\n                               buttons = list('copy', 'csv', 'excel', 'print') ),\n               caption = \"Preview of uploaded data (Filtered Rows Removed; Columns Identified Post-Filtering).\" )\n  })\n  \n  # --- Render Processed Marks Interactive Table (DT - Unchanged) ---\n  # Displays display_data() which is filtered for numeric IDs and PP row\n  output$processedMarksTable <- renderDT({\n    marks_to_show <- display_data() # This reactive already handles filtering and column order\n    validate(need(!is.null(marks_to_show) && nrow(marks_to_show) > 0, \"No processed marks with numeric IDs to display in table.\"))\n    \n    # Default sorting by 'submitted' column if it exists\n    submitted_col_index <- which(colnames(marks_to_show) == \"submitted\")\n    dt_order <- if (length(submitted_col_index) == 1) { list(list(submitted_col_index - 1, 'desc')) } else { list() } # DT uses 0-based index\n    \n    dt <- datatable(marks_to_show, rownames = FALSE, extensions = c('Scroller'),\n                    options = list( pageLength = 10, scrollX = TRUE, scrollY = \"400px\", deferRender = TRUE, scroller = TRUE,\n                                    dom = 'frtip', # Use 'f' for filter, 'r' processing display, 't' table, 'i' info, 'p' pagination\n                                    order = dt_order\n                    )\n    )\n    \n    # Apply number formatting\n    num_cols_format2 <- intersect(c(\"HW\", \"Test\", \"Final_Score\", \"calculated\", \"maxFinal\"), names(marks_to_show))\n    num_cols_format0 <- intersect(c(\"submitted\", \"Nhw\", \"Ntest\"), names(marks_to_show))\n    if(length(num_cols_format2) > 0) dt <- formatRound(dt, columns = num_cols_format2, digits = 2)\n    if(length(num_cols_format0) > 0) dt <- formatRound(dt, columns = num_cols_format0, digits = 0)\n    \n    dt\n  })\n  \n  # --- Render Processed Marks Spreadsheet View (Handsontable - Unchanged) ---\n  # Displays display_data() which is filtered for numeric IDs and PP row\n  output$processedMarksSpreadsheet <- renderRHandsontable({\n    marks_to_show <- display_data() # This reactive already handles filtering and column order\n    validate(need(!is.null(marks_to_show) && nrow(marks_to_show) > 0, \"No processed marks with numeric IDs to display in spreadsheet.\"))\n    \n    hot <- rhandsontable(\n      marks_to_show,\n      rowHeaders = NULL, readOnly = TRUE, stretchH = \"all\", height = 550,\n      columnSorting = TRUE, manualColumnResize = TRUE, colWidths = 100 # Adjust colWidths as needed\n    )\n    \n    # Apply formatting and alignment\n    current_colnames <- colnames(marks_to_show)\n    num_cols_format2 <- intersect(c(\"HW\", \"Test\", \"Final_Score\", \"calculated\", \"maxFinal\"), current_colnames)\n    num_cols_format0 <- intersect(c(\"submitted\", \"Nhw\", \"Ntest\"), current_colnames)\n    # Try to left-align the first two columns (typically Student/ID)\n    left_align_cols <- current_colnames[1:min(2, ncol(marks_to_show))]\n    \n    if(length(num_cols_format2) > 0) { hot <- hot_cols(hot, format = \"0.00\", halign = \"htRight\", cols = num_cols_format2) }\n    if(length(num_cols_format0) > 0) { hot <- hot_cols(hot, format = \"0\", halign = \"htRight\", cols = num_cols_format0) }\n    valid_left_align_cols <- intersect(left_align_cols, current_colnames) # Ensure columns exist\n    if(length(valid_left_align_cols) > 0) { hot <- hot_cols(hot, halign = \"htLeft\", cols = valid_left_align_cols) }\n    \n    hot\n  })\n  \n  # --- Download Handler for CSV with Notes (Unchanged) ---\n  # Uses display_data() for export\n  # --- Assumed Libraries & Objects ---\n  # library(shiny)\n  # library(tools)\n  # # Assumes rv, display_data(), generate_notes_text() are defined elsewhere in server\n  \n  # --- Download Handler for CSV with Notes (Data Written First) ---\n  output$downloadCsvWithNotes <- downloadHandler(\n    filename = function() {\n      # Ensure a file has been uploaded\n      req(input$markFile, cancelOutput = TRUE)\n      # Create a filename based on the input file, adding suffix and timestamp\n      in_basename <- basename(input$markFile$name)\n      in_base_noext <- tools::file_path_sans_ext(in_basename)\n      paste0(in_base_noext, \"_processed_\", format(Sys.time(), \"%Y%m%d_%H%M\"), \".csv\")\n    },\n    content = function(file) {\n      # Ensure calculation parameters and results are available\n      req(rv$calculation_params, rv$calculated_results$identified_columns)\n      # Ensure display_data() can be generated without error\n      validate(need(tryCatch({ !is.null(display_data()) }, error = function(e) FALSE),\n                    \"Calculation results are needed for export. Please calculate first.\"))\n      # Get the main data to export (filtered, ordered)\n      data_to_export <- display_data()\n      validate(need(!is.null(data_to_export) && nrow(data_to_export) > 0,\n                    \"No processed student data with numeric IDs is available to export.\"))\n      \n      # --- Generate and Prepare Notes ---\n      # Generate the notes text based on current parameters and identified columns\n      notes_text <- generate_notes_text(rv$calculation_params, rv$calculated_results$identified_columns)\n      # Split the notes text into individual lines\n      notes_lines <- strsplit(notes_text, \"\\n\")[[1]]\n      # Create a data frame where the notes form a single column\n      # This structure allows write.table to handle quoting correctly.\n      notes_df <- data.frame(CalculationNotes = notes_lines)\n      \n      # --- Write Main Data to CSV First ---\n      # Write the actual processed grade data first.\n      write.table(data_to_export, file,\n                  sep = \",\",\n                  row.names = FALSE,\n                  col.names = TRUE,      # Include the column headers for the main data\n                  append = FALSE,        # Do NOT append, this is the first write\n                  qmethod = \"double\",    # Ensure proper quoting for the data\n                  na = \"\"                # Write NA values as empty strings\n      )\n      \n      # --- Add Separator (Optional) ---\n      # Write an empty line to visually separate data from notes\n      write(\"\", file, append = TRUE)\n      \n      # --- Append Notes to CSV ---\n      # Append the notes data frame below the main data.\n      # Each note line becomes a row in the first column.\n      write.table(notes_df, file,\n                  sep = \",\",             # Use comma as the separator\n                  row.names = FALSE,     # Do not include data frame row numbers\n                  col.names = FALSE,     # Do not include the header (\"CalculationNotes\")\n                  append = TRUE,         # Append to the existing file content (the data)\n                  qmethod = \"double\",    # Use double quotes around fields containing commas, quotes, etc.\n                  na = \"\"                # Write NA values as empty strings\n      )\n      \n    },\n    # Set the content type for the download\n    contentType = \"text/csv\"\n  ) # End downloadHandler\n  \n  # --- Download Handler for Excel with Notes (Unchanged) ---\n  # Uses display_data() for export\n  output$downloadXlsxWithNotes <- downloadHandler(\n    filename = function() {\n      req(input$markFile, cancelOutput = TRUE)\n      in_basename <- basename(input$markFile$name)\n      in_base_noext <- tools::file_path_sans_ext(in_basename)\n      paste0(in_base_noext, \"_processed_\", format(Sys.time(), \"%Y%m%d_%H%M\"), \".xlsx\") # Add timestamp\n    },\n    content = function(file) {\n      req(rv$calculation_params, rv$calculated_results$identified_columns)\n      validate(need(tryCatch({ !is.null(display_data()) }, error = function(e) FALSE), \"Calculation results needed for export.\"))\n      data_to_export <- display_data() # Get the filtered, ordered data\n      validate(need(!is.null(data_to_export) && nrow(data_to_export) > 0, \"No data available to export.\"))\n      \n      # Generate notes using the parameters and final identified columns\n      notes_text <- generate_notes_text(rv$calculation_params, rv$calculated_results$identified_columns)\n      notes_lines <- strsplit(notes_text, \"\\n\")[[1]]\n      # Create a dataframe for the notes sheet\n      notes_df <- data.frame(Notes = notes_lines)\n      \n      # Create list for sheets\n      sheets <- list(\n        \"Calculation Notes\" = notes_df,\n        \"Processed Grades\" = data_to_export\n      )\n      \n      # Write Excel file using writexl\n      writexl::write_xlsx(sheets, path = file)\n    },\n    contentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n  )\n  \n  # --- Render Calculation Notes (for in-app display - Unchanged) ---\n  # Uses rv$calculation_params and rv$calculated_results$identified_columns\n  output$processedMarksNotes <- renderUI({\n    validate(need(!is.null(rv$calculation_params) && !is.null(rv$calculated_results$identified_columns),\n                  \"Calculate grades first to see parameters used and column definitions.\"))\n    params <- rv$calculation_params;\n    cols_info <- rv$calculated_results$identified_columns # Use the final identified cols list\n    student_col_name_actual <- if(!is.null(cols_info) && !is.na(cols_info$student)) cols_info$student else \"Student Col?\"\n    id_col_name_actual <- if(!is.null(cols_info) && !is.na(cols_info$id)) cols_info$id else \"ID Col?\"\n    \n    # Format parameters for display\n    weights_str <- sprintf(\"HW=%.3f, Test=%.3f, Final=%.3f\", params$weights[\"HW\"], params$weights[\"Test\"], params$weights[\"Final\"])\n    options_str <- sprintf(\"Fill HW=%s, Fill Test=%s, MaxFinal=%s\", params$fill.hw, params$fill.test, params$final.only)\n    omissions_str <- sprintf(\"Omit HW=%d, Omit Test=%d\", params$n.omitted.hw, params$n.omitted.test)\n    rules_display <- if (!is.null(params$adjustment_rules_string) && nzchar(str_trim(params$adjustment_rules_string))) {\n      tagList( tags$li(tags$strong(\"Adjustment Rules String Used:\")), tags$ul(style=\"margin-left: 20px;\", tags$li(tags$code(params$adjustment_rules_string))) )\n    } else { tags$li(tags$strong(\"Adjustments:\"), \" None applied.\") }\n    \n    # Build the UI elements\n    tagList(\n      tags$p(tags$strong(\"Parameters Used:\")),\n      tags$ul(\n        tags$li(paste(\"Weights (as decimals):\", weights_str)),\n        tags$li(paste(\"Options:\", options_str)),\n        tags$li(paste(\"Omissions:\", omissions_str)),\n        rules_display\n      ),\n      tags$hr(),\n      tags$p(tags$strong(\"Column Definitions (in results table):\")),\n      tags$ul(\n        tags$li(tags$code(student_col_name_actual), \"/\", tags$code(id_col_name_actual), \": Student identifiers.\"),\n        tags$li(tags$code(\"Nhw\"), \"/\", tags$code(\"Ntest\"), \": # Submitted HW/Test (using only columns with valid Points Possible).\"),\n        tags$li(tags$code(\"HW\"), \"/\", tags$code(\"Test\"), \": Weighted component score %.\"),\n        tags$li(tags$code(\"Final_Score\"), \": Final Exam score %.\"),\n        tags$li(tags$code(\"calculated\"), \": Initial total % = Weighted(HW+Test+Final).\"),\n        tags$li(tags$code(\"maxFinal\"), \": Max(calculated, Final_Score) if option checked.\"),\n        tags$li(tags$code(\"submitted\"), \": Final rounded grade % (capped at rule's upper bound or 99 overall).\")\n      ),\n      tags$hr(),\n      tags$p(tags$strong(\"Note on Displayed Table:\"),\n             \" The main results table/spreadsheet above shows only rows where the identified ID column (\", tags$code(id_col_name_actual), \") contains a numeric value and excludes the 'Points Possible' row.\",\n             \" Calculated results for the 'Points Possible' row and rows with non-numeric IDs (which were included in the calculation but excluded from this table) are shown separately in the 'Verification Information' section above.\"\n      )\n    )\n  })\n  \n  # --- Statistics Section (Unchanged) ---\n  # Depends on display_data() which is already filtered\n  summary_data <- reactive({\n    req(display_data()) # Requires the filtered, ordered data for display\n    df_for_stats <- display_data()\n    validate(need(nrow(df_for_stats) > 0, \"No data available for statistics.\"),\n             need(\"submitted\" %in% names(df_for_stats), \"Cannot find 'submitted' column for stats.\"),\n             need(is.numeric(df_for_stats$submitted), \"'submitted' column is not numeric.\"))\n    # Ensure scores are numeric and remove NAs before calculating stats\n    scores <- as.numeric(df_for_stats$submitted)\n    scores <- scores[!is.na(scores)]\n    validate(need(length(scores) > 0, \"No valid numeric 'submitted' scores found for stats.\"))\n    scores\n  })\n  \n  output$summaryStats <- renderPrint({\n    scores <- summary_data(); n_obs <- length(scores)\n    # Calculate stats safely, handling cases with 0 or 1 observation\n    mean_val <- if (n_obs > 0) mean(scores, na.rm = TRUE) else NA\n    median_val <- if (n_obs > 0) median(scores, na.rm = TRUE) else NA\n    sd_val <- if (n_obs > 1) sd(scores, na.rm = TRUE) else NA\n    iqr_val <- if (n_obs > 0) IQR(scores, na.rm = TRUE, type = 7) else NA\n    se_val <- if (!is.na(sd_val) && n_obs > 0) sd_val / sqrt(n_obs) else NA\n    min_val <- if(n_obs > 0) min(scores, na.rm = TRUE) else NA\n    max_val <- if(n_obs > 0) max(scores, na.rm = TRUE) else NA\n    \n    # Formatting output\n    cat(\"Summary Statistics ('submitted' grades from displayed table)\\n\")\n    cat(rep(\"-\", 80), \"\\n\", sep=\"\") # Adjust width if needed\n    cat(sprintf(\"N: %-6d    Mean: %-8.2f    Median: %-8.2f    Std Dev: %-7.2f\\n\",\n                n_obs,\n                ifelse(is.na(mean_val), NA, mean_val),\n                ifelse(is.na(median_val), NA, median_val),\n                ifelse(is.na(sd_val), NA, sd_val)))\n    cat(sprintf(\"Min: %-6.1f    Max: %-9.1f    IQR: %-10.2f    Std Err: %-8.3f\\n\",\n                ifelse(is.na(min_val), NA, min_val),\n                ifelse(is.na(max_val), NA, max_val),\n                ifelse(is.na(iqr_val), NA, iqr_val),\n                ifelse(is.na(se_val), NA, se_val)))\n    cat(rep(\"-\", 80), \"\\n\", sep=\"\")\n    \n    # Quantiles\n    if (n_obs > 0) {\n      q_probs <- seq(0, 1, by = 0.1)\n      q_vals <- quantile(scores, probs = q_probs, type = 7, na.rm = TRUE)\n      q_names <- paste0(format(q_probs * 100, nsmall=0), \"%\")\n      col_width <- 8 # Adjust spacing\n      q_labels_formatted <- sprintf(paste0(\"%-\", col_width, \"s\"), q_names)\n      q_values_formatted <- sprintf(paste0(\"%-\", col_width, \".1f\"), q_vals)\n      cat(\"Quantiles:\\n\")\n      cat(\"      \", paste(q_labels_formatted, collapse = \"\"), \"\\n\")\n      cat(\"      \", paste(q_values_formatted, collapse = \"\"), \"\\n\")\n    } else {\n      cat(\"Quantiles: Not available (N=0)\\n\")\n    }\n    cat(rep(\"-\", 80), \"\\n\", sep=\"\")\n  })\n  \n  # --- Plots Section (Unchanged) ---\n  # Depends on summary_data() which uses display_data()\n  output$distPlots <- renderPlot({\n    scores <- summary_data(); # Get the valid, numeric scores\n    validate(need(length(scores) > 0, \"No data to plot (after filtering for numeric IDs and PP row).\"))\n    df_plot <- data.frame(scores = scores)\n    \n    # Define plot parameters\n    min_score <- 0; max_score <- 100; bin_width <- 10\n    breaks <- seq(min_score, max_score, by = bin_width)\n    axis_max <- max_score # Or adjust if needed, e.g., max(max_score, max(scores, na.rm=TRUE))\n    \n    # Histogram\n    p1 <- ggplot(df_plot, aes(x = scores)) +\n      geom_histogram(aes(y = after_stat(count)), breaks = breaks, fill = \"#56B4E9\", color = \"white\", closed = \"left\", boundary=0) +\n      # Add count labels above bars (only if count > 0)\n      stat_bin(aes(y = after_stat(count), label = ifelse(after_stat(count) > 0, after_stat(count), \"\")),\n               geom = \"text\", vjust = -0.5, size = 3.5, breaks = breaks, closed = \"left\", boundary=0) +\n      scale_x_continuous(name = \"Submitted Score \", breaks = breaks, limits = c(min_score, axis_max)) +\n      scale_y_continuous(name = \"Frequency\", expand = expansion(mult = c(0.01, 0.1))) + # Add space for labels\n      labs(title = \"Grade Distribution ('submitted' from displayed table)\") +\n      theme_minimal(base_size = 12) +\n      theme(plot.title = element_text(hjust = 0.5))\n    \n    # ECDF Plot\n    p2 <- ggplot(df_plot, aes(x = scores)) +\n      stat_ecdf(geom = \"step\", pad = FALSE, color = \"#0072B2\", linewidth = 1) +\n      scale_y_continuous(name = \"Cumulative %\", breaks = seq(0, 1, by = 0.1), labels = scales::percent_format(accuracy=1)) +\n      scale_x_continuous(name = \"Submitted Score \", breaks = seq(0, 100, by = 10), limits = c(min_score, axis_max)) +\n      labs(title = \"ECDF ('submitted' from displayed table)\") +\n      theme_minimal(base_size = 12) +\n      theme(panel.grid.major = element_line(colour = \"grey92\"), # Keep major grids\n            panel.grid.minor = element_blank(), # Remove minor grids\n            plot.title = element_text(hjust = 0.5))\n    \n    # Combine plots using patchwork\n    p1 + p2\n  }, res = 96) # Set resolution for the plot output\n  \n} # End server function\n\n\n\n# --- Run the application ---\nshinyApp(ui = ui, server = server)","type":"text"},{"name":"calculatemark.Rproj","content":"Version: 1.0\nProjectId: a750c239-51b7-43f3-b5cc-aae99185c3e7\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 4\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n","type":"text"},{"name":"readme.txt","content":"A shiny app for calculating students' marks.\n","type":"text"}]
