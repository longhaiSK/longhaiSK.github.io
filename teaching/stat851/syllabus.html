<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>STAT 443/851 Theory of Linear Models (University of Saskatchewan, 2026-01)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="syllabus_files/libs/clipboard/clipboard.min.js"></script>
<script src="syllabus_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="syllabus_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="syllabus_files/libs/quarto-html/popper.min.js"></script>
<script src="syllabus_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="syllabus_files/libs/quarto-html/anchor.min.js"></script>
<link href="syllabus_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="syllabus_files/libs/quarto-html/quarto-syntax-highlighting-1b3e43c72e8be34557c75123b0b69e0d.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="syllabus_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="syllabus_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="syllabus_files/libs/bootstrap/bootstrap-355a6a3f67f4ec946dc3f7101c6e2584.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="/resources/loadtoc.js"></script>
<script src="/resources/rendernav.js" defer=""></script>
<link rel="stylesheet" href="/resources/mystyles.css">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#instructor" id="toc-instructor" class="nav-link active" data-scroll-target="#instructor">Instructor</a></li>
  <li><a href="#description" id="toc-description" class="nav-link" data-scroll-target="#description">Description</a></li>
  <li><a href="#textbook-and-course-materials" id="toc-textbook-and-course-materials" class="nav-link" data-scroll-target="#textbook-and-course-materials">Textbook and Course Materials</a></li>
  <li><a href="#list-of-topics" id="toc-list-of-topics" class="nav-link" data-scroll-target="#list-of-topics">List of Topics</a></li>
  <li><a href="#times-and-places" id="toc-times-and-places" class="nav-link" data-scroll-target="#times-and-places">Times and Places</a></li>
  <li><a href="#evaluation-components" id="toc-evaluation-components" class="nav-link" data-scroll-target="#evaluation-components">Evaluation Components</a>
  <ul>
  <li><a href="#grading-scheme" id="toc-grading-scheme" class="nav-link" data-scroll-target="#grading-scheme">Grading Scheme</a></li>
  <li><a href="#assignments-and-tests" id="toc-assignments-and-tests" class="nav-link" data-scroll-target="#assignments-and-tests">Assignments and Tests</a></li>
  <li><a href="#assignments" id="toc-assignments" class="nav-link" data-scroll-target="#assignments">Assignments</a></li>
  <li><a href="#midterm" id="toc-midterm" class="nav-link" data-scroll-target="#midterm">Midterm</a></li>
  <li><a href="#final-exam" id="toc-final-exam" class="nav-link" data-scroll-target="#final-exam">Final Exam</a></li>
  </ul></li>
  <li><a href="#criteria-that-must-be-met-to-pass" id="toc-criteria-that-must-be-met-to-pass" class="nav-link" data-scroll-target="#criteria-that-must-be-met-to-pass">Criteria That Must Be Met to Pass</a></li>
  <li><a href="#attendance-expectation" id="toc-attendance-expectation" class="nav-link" data-scroll-target="#attendance-expectation">Attendance Expectation</a></li>
  <li><a href="#recording-of-the-course" id="toc-recording-of-the-course" class="nav-link" data-scroll-target="#recording-of-the-course">Recording of the Course</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">STAT 443/851 Theory of Linear Models (University of Saskatchewan, 2026-01)</h1>
</div>



<div class="quarto-title-meta column-page-right">

    
  
    
  </div>
  


</header>


<section id="instructor" class="level2">
<h2 class="anchored" data-anchor-id="instructor">Instructor</h2>
<p><a href="https://longhaisk.github.io/">Longhai Li</a>, Professor, Department of Mathematics and Statistics, University of Saskatchewan Email: longhai.li@usask.ca, Phone: 9666095, Office: 219 MCLN.</p>
</section>
<section id="description" class="level2">
<h2 class="anchored" data-anchor-id="description">Description</h2>
<p>This course is a rigorous examination of the general linear models using vector space theory, in particular the approach of regarding least square as projection. The topics includes: vector space; projection; matrix algebra; generalized inverses; quadratic forms; theory for point estimation; theory for hypothesis test; theory for non-full-rank models.</p>
<p><strong>Prerequisite(s):</strong> MATH 164 (formerly MATH 264) or MATH 266, STAT 342, and STAT 344 or 345.</p>
</section>
<section id="textbook-and-course-materials" class="level2">
<h2 class="anchored" data-anchor-id="textbook-and-course-materials">Textbook and Course Materials</h2>
<ul>
<li>LINEAR MODELS IN STATISTICS, Second Edition, by Alvin C. Rencher and G. Bruce Schaalje, ISBN 978-0-471-75498-5 (cloth). <em>The book is not required but it is good to have it.</em></li>
<li>I will primarily follow my own lecture notes. The assignments and solutions are available in a one-drive folder. All the links are given on <a href=".">this page</a>.</li>
</ul>
</section>
<section id="list-of-topics" class="level2">
<h2 class="anchored" data-anchor-id="list-of-topics">List of Topics</h2>
<ol type="1">
<li>Vector Space and Projection (supplemented or Ch 4,5,7 in Kuttler’s book)</li>
<li>Matrix Algebra (Ch 1 and 2 in LINEAR MODELS IN STATISTICS)</li>
<li>Distribution of Multivariate Normal (Ch 3,4 in LINEAR MODELS IN STATISTICS)</li>
<li>Distribution of Quadratic Forms (Generalization of Sum Squares) (Ch 5 in LINEAR MODELS IN STATISTICS)</li>
<li>Theory for Multiple Regression (Ch 6, 7, 8 in LINEAR MODELS IN STATISTICS)</li>
<li>Non-full-rank Models (Ch 12 in LINEAR MODELS IN STATISTICS)</li>
</ol>
</section>
<section id="times-and-places" class="level2">
<h2 class="anchored" data-anchor-id="times-and-places">Times and Places</h2>
<p>Lecture Classroom: MCLN 242.1, MWF 9:30-10:20; Office hour: TBA; Lab: no lab.</p>
</section>
<section id="evaluation-components" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-components">Evaluation Components</h2>
<section id="grading-scheme" class="level3">
<h3 class="anchored" data-anchor-id="grading-scheme">Grading Scheme</h3>
<p><strong>3 assignments: 3x10% = 30%, 1 term test: 20%, final exam: 50%.</strong></p>
</section>
<section id="assignments-and-tests" class="level3">
<h3 class="anchored" data-anchor-id="assignments-and-tests">Assignments and Tests</h3>
<p><strong>Assignment questions are released in the one-drive folder</strong>. You will submit your solutions via Canvas. <strong>If you miss an assignment without proper excuse, the weight will NOT be shifted to the final.</strong> Undergraduate students will be assigned with different assignments and tests.</p>
</section>
<section id="assignments" class="level3">
<h3 class="anchored" data-anchor-id="assignments">Assignments</h3>
<ul>
<li>I will accept late assignments only for three (3) days beyond the due date. The penalty for your delay is 10 percentage points per day of lateness from the value of the assignment (including weekends). <strong>Extensions are only granted in rare instances (notably as a result of family or medical emergencies) and upon receipt of adequate documentation/proof.</strong></li>
<li>Answer the questions in the order they appear in the assignment. Neatness is important.</li>
<li>Solutions to problems are to be included. Hence, simple answers without work will receive few (or no!) marks.</li>
<li>Most problems in statistics have a “real-life” basis. Hence, solutions should include not only numerical solutions but also a statement as to what the numbers say about the problem.</li>
<li>The work handed in must not be an exact duplicate of others.</li>
<li>Submitting Assignments: The assignment can be typed and/or handwritten. Save your assignment as <strong>one PDF file</strong> (for handwritten assignments, feel free to take a picture/scan of your work and save it as one PDF file). Upload the <strong>PDF file</strong> as an assignment submission in Canvas.</li>
<li>More details will be provided ahead of each assignment.</li>
<li>Due Date: See Course Schedule.</li>
</ul>
</section>
<section id="midterm" class="level3">
<h3 class="anchored" data-anchor-id="midterm">Midterm</h3>
<ul>
<li>The midterm is given in class period.</li>
<li>Midterms must be written on the dates scheduled. Students must do midterms completely on their own. More details (including syllabus) will be provided ahead of each midterm.</li>
<li>Type: Short-answer questions, problem-solving, open-book.</li>
<li>Calculator: A scientific calculator is allowed.</li>
<li>Make-up exam will not be given. If you miss an exam for a legitimate reason (e.g., illness, emergency) and notify me within 48 hours of the scheduled exam, the weight of the missed exam will be transferred to the final exam.</li>
</ul>
</section>
<section id="final-exam" class="level3">
<h3 class="anchored" data-anchor-id="final-exam">Final Exam</h3>
<ul>
<li>Scheduling: Final examinations may be scheduled at any time during the examination period; students should therefore avoid making prior travel, employment, or other commitments for this period. If a student is unable to write an exam through no fault of their own for medical or other valid reasons, documentation must be provided and an opportunity to write the missed exam may be given. Students are encouraged to review all examination policies and procedures: <a href="http://students.usask.ca/academics/exams.php">http://students.usask.ca/academics/exams.php</a>.</li>
<li>The final exam will cover material of the entire course. More details will be provided ahead of the exam.</li>
<li>Length: 3-hour in-person exam.</li>
<li>Type: Short-answer questions, problem-solving, open-book.</li>
</ul>
</section>
</section>
<section id="criteria-that-must-be-met-to-pass" class="level2">
<h2 class="anchored" data-anchor-id="criteria-that-must-be-met-to-pass">Criteria That Must Be Met to Pass</h2>
<p>The <strong>final exam is a required component of the course</strong>. Students must complete the final exam in order to be eligible to receive a passing grade in this class.</p>
</section>
<section id="attendance-expectation" class="level2">
<h2 class="anchored" data-anchor-id="attendance-expectation">Attendance Expectation</h2>
<p>Attendance is highly correlated with student performance. While a syllabus and suggested readings are provided, it is not an adequate substitute for attending class. Your <strong>attendance is highly recommended</strong> but not required, and you will not be graded on your attendance.</p>
</section>
<section id="recording-of-the-course" class="level2">
<h2 class="anchored" data-anchor-id="recording-of-the-course">Recording of the Course</h2>
<p>Recording of the lectures will only be allowed in certain circumstances. Please see the instructor for information on how to receive approval. In general, there will be no videos available for in-person lectures. Therefore, <strong>attendance is strongly recommended</strong>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>