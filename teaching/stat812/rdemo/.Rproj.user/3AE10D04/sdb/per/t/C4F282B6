{
    "contents" : "source (\"ars_tnorm.R\")\n\n######################### estimate P(a < X < b) ##############################\n## estimating the probability P(X in A) for X ~ N(0,1) \n## by sampling from N(0,1)\nest_normprob_mc <- function(A,iters_mc)\n{\n     X <- rnorm(iters_mc)\n     mean((X > A[1]) * (X<A[2]))\n}\n\n## estimating the probability P(X in A) for X ~ N(0,1) \n## by sampling from Unif(A[1],A[2])\nest_normprob_imps <- function(A, iters_mc)\n{\n     X <- runif(iters_mc,A[1],A[2])\n     mean(dnorm(X))*(A[2]-A[1])\n}\n \nA <- c(-2,2)\nprobs_mc <- replicate(1000,est_normprob_mc(A,100))\nprobs_imps <- replicate(1000,est_normprob_imps(A,100))\nvar(probs_mc)\nvar(probs_imps)\n\nA <- c(1.5,2)\nprobs_mc <- replicate(1000,est_normprob_mc(A,100))\nprobs_imps <- replicate(1000,est_normprob_imps(A,100))\nvar(probs_mc)\nvar(probs_imps)\n\n######################### Estimate E(X^2) ####################################\n\n## compute E(a) with importance sampling\nest_tnorm_imps <- function(a, A, iters_mc)\n{\n    X <- runif(iters_mc,A[1],A[2])\n    W <- dnorm (X)\n    Ahat <- sum (a(X) * W) / sum (W)\n    attr(Ahat, \"effective sample size\") <- 1/sum((W/sum(W))^2)\n    Ahat\n}\n\n## a function computing the sum of numbers represented with logarithm\n## lx     --- a vector of numbers, which are the log of another vector x.\n## the log of sum of x is returned\nlog_sum_exp <- function(lx)\n{   mlx <- max(lx)\n    mlx + log(sum(exp(lx-mlx)))\n}\n\n## a generic function for approximating 1-D integral with midpoint rule\n## the logarithms of the function values are passed in\n## the log of the integral result is returned\n## log_f  --- a function computing the logarithm of the integrant function\n## range  --- the range of integral varaible, a vector of two elements\n## n      --- the number of points at which the integrant is evaluated\n## ...    --- other parameters needed by log_f\nlog_int_mid <- function(log_f, range, n,...)\n{   if(range[1] >= range[2]) \n    stop(\"Wrong ranges\")\n    h <- (range[2]-range[1]) / n\n    v_log_f <- sapply(range[1] + (1:n - 0.5) * h, log_f,...)\n    log_sum_exp(v_log_f) + log(h)       \n}\n\n## compute E(a) with midpoint rule\nest_tnorm_mid <- function (a, A, iters_mc)\n{\n    log_f <- function (x) dnorm (x, log = T) + log (a(x))\n    exp(log_int_mid (log_f, A, iters_mc) ) / (pnorm (A[2]) - pnorm (A[1]))\n}\n\n## define the function a\na <- function (x) x^2\n\nA <- est_tnorm_mid (a, c(1,2), 10000) ## midpoint rule\nest_tnorm_imps (a, c(1,2), 1000) ## importance sampling\n\n## estimate E(a) with rejection sampling\nrn_tnorm_ars <- sample_tnorm_ars (1000, 1,2) # draw samples from tnorm\nmean (a (rn_tnorm_ars)) \n\n## simulation comparison of importance sampling and rejection sampling\ntimes.imps <- system.time(\nEA_imps <- replicate (1000, est_tnorm_imps (a, c(1,2), 9000)) \n)\n\ntimes.rej <- system.time (\nEA_rej <- replicate (1000,\n    {   rn_tnorm_ars <- sample_tnorm_ars (860, 1,2)\n        mean (a (rn_tnorm_ars))\n    }\n    )\n)\n\npar (mfrow = c(1,2))\nhist (EA_imps); mean (EA_imps); sd (EA_imps)\nhist (EA_rej); mean (EA_rej); sd (EA_rej)\n\n## find MSE / time\n(1/mean ((EA_imps - A)^2))/times.imps[1]\n(1/mean ((EA_rej - A)^2))/times.rej[1]\n\nsave.image (\"normprob.RData\")\n\n",
    "created" : 1415215973845.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1883716555",
    "id" : "C4F282B6",
    "lastKnownWriteTime" : 1415217840,
    "path" : "/Volumes/longhai/public_html/teaching/stat812-1409/rdemo/normprob-imps.R",
    "project_path" : "normprob-imps.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}